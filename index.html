<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"goversion.github.io","root":"/","images":"/images","scheme":"Pisces","darkmode":false,"version":"8.24.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://goversion.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhou tao">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://goversion.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hexo</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Hexo</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhou tao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://goversion.github.io/2025/08/31/os5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhou tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/31/os5/" class="post-title-link" itemprop="url">os5</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-31 17:44:26 / 修改时间：17:46:16" itemprop="dateCreated datePublished" datetime="2025-08-31T17:44:26+08:00">2025-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OS-第五章：进程"><a href="#OS-第五章：进程" class="headerlink" title="OS 第五章：进程"></a>OS 第五章：进程</h1><h2 id="1-为什么要有进程？"><a href="#1-为什么要有进程？" class="headerlink" title="1 为什么要有进程？"></a>1 为什么要有进程？</h2><p>在前面的章节里，内核和用户程序的交互比较有限，仅是加载一下 app 就结束了。内核还缺乏对用户程序的<strong>抓手</strong>。</p>
<p>因此，为了描述进程，我们需要创建一些数据结构，即进程控制块 PCB，便于控制程序。从资源角度来看，进程是程序执行中占用资源的集合。</p>
<h2 id="2-四个重要的系统调用"><a href="#2-四个重要的系统调用" class="headerlink" title="2 四个重要的系统调用"></a>2 四个重要的系统调用</h2><p>首先要讲几个系统调用的实现</p>
<h3 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork"></a>2.1 fork</h3><p><img src="/./pics/5_01.png"></p>
<p>fork 就是复制一份，新的一份就是子进程。</p>
<p>fork 返回 0 时是子进程，返回不为 0 时是子进程的 pid。</p>
<h3 id="2-2-exec"><a href="#2-2-exec" class="headerlink" title="2.2 exec"></a>2.2 exec</h3><p>看上图，在代码段，把当前的代码填充进去。</p>
<h3 id="2-3-exit"><a href="#2-3-exit" class="headerlink" title="2.3 exit"></a>2.3 exit</h3><p>进程结束时调用 exit，完成进程的第一次资源的回收，然后将该进程标识为<strong>僵尸进程</strong>，由父进程使用 wait 来收拾残局，进行第二次资源的回收。</p>
<p>然后准备向父进程发送返回值之前，先检查父进程是否存活。</p>
<p>如果存在，父进程执行回收。</p>
<p>如果不存在，把本进程的父进程设为 init 进程，然后 init 进程执行回收。一般 init 进程不会做很复杂的事，主要做回收。</p>
<h3 id="2-4-wait"><a href="#2-4-wait" class="headerlink" title="2.4 wait"></a>2.4 wait</h3><p>父进程等待子进程的结束。</p>
<p>子进程要退出时，通过 exit 向父进程发送返回值，父进程通过 wait 接受。</p>
<h2 id="3-进程实现"><a href="#3-进程实现" class="headerlink" title="3 进程实现"></a>3 进程实现</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Directly save the contents that will not change during running</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlock</span> &#123;</span><br><span class="line">    <span class="comment">// Immutable</span></span><br><span class="line">    <span class="comment">/// Process identifier</span></span><br><span class="line">    <span class="keyword">pub</span> pid: PidHandle,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Kernel stack corresponding to PID</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_stack: KernelStack,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Mutable</span></span><br><span class="line">    inner: UPSafeCell&lt;TaskControlBlockInner&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TaskControlBlockInner</span> &#123;</span><br><span class="line">    <span class="comment">/// The physical page number of the frame where the trap context is placed</span></span><br><span class="line">    <span class="keyword">pub</span> trap_cx_ppn: PhysPageNum,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Application data can only appear in areas</span></span><br><span class="line">    <span class="comment">/// where the application address space is lower than base_size</span></span><br><span class="line">    <span class="keyword">pub</span> base_size: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Save task context</span></span><br><span class="line">    <span class="keyword">pub</span> task_cx: TaskContext,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Maintain the execution status of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> task_status: TaskStatus,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Application address space</span></span><br><span class="line">    <span class="keyword">pub</span> memory_set: MemorySet,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Parent process of the current process.</span></span><br><span class="line">    <span class="comment">/// Weak will not affect the reference count of the parent</span></span><br><span class="line">    <span class="keyword">pub</span> parent: <span class="type">Option</span>&lt;Weak&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// A vector containing TCBs of all child processes of the current process</span></span><br><span class="line">    <span class="keyword">pub</span> children: <span class="type">Vec</span>&lt;Arc&lt;TaskControlBlock&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// It is set when active exit or execution error occurs</span></span><br><span class="line">    <span class="keyword">pub</span> exit_code: <span class="type">i32</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Heap bottom</span></span><br><span class="line">    <span class="keyword">pub</span> heap_bottom: <span class="type">usize</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Program break</span></span><br><span class="line">    <span class="keyword">pub</span> program_brk: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-几个系统调用的实现"><a href="#4-几个系统调用的实现" class="headerlink" title="4 几个系统调用的实现"></a>4 几个系统调用的实现</h2><h3 id="4-1-fork-的实现"><a href="#4-1-fork-的实现" class="headerlink" title="4.1 fork 的实现"></a>4.1 fork 的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_fork</span>() <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_task</span> = <span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_task</span> = current_task.fork();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_pid</span> = new_task.pid.<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// modify trap context of new_task, because it returns immediately after switching</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = new_task.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    <span class="comment">// we do not have to move to next instruction since we have done it before</span></span><br><span class="line">    <span class="comment">// for child process, fork returns 0</span></span><br><span class="line">    trap_cx.x[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// add new task to scheduler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把这个进程放在就绪队列里。</span></span><br><span class="line">    <span class="title function_ invoke__">add_task</span>(new_task);</span><br><span class="line">    new_pid <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fork</span>(<span class="keyword">self</span>: &amp;Arc&lt;<span class="keyword">Self</span>&gt;) <span class="punctuation">-&gt;</span> Arc&lt;<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// ---- access parent PCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">parent_inner</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制地址空间</span></span><br><span class="line">    <span class="comment">// copy user space(include trap context)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">memory_set</span> = MemorySet::<span class="title function_ invoke__">from_existed_user</span>(&amp;parent_inner.memory_set);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_ppn</span> = memory_set</span><br><span class="line">        .<span class="title function_ invoke__">translate</span>(VirtAddr::<span class="title function_ invoke__">from</span>(TRAP_CONTEXT).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ppn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// alloc a pid and a kernel stack in kernel space</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pid_handle</span> = <span class="title function_ invoke__">pid_alloc</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kernel_stack</span> = KernelStack::<span class="title function_ invoke__">new</span>(&amp;pid_handle);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">kernel_stack_top</span> = kernel_stack.<span class="title function_ invoke__">get_top</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task_control_block</span> = Arc::<span class="title function_ invoke__">new</span>(TaskControlBlock &#123;</span><br><span class="line">        pid: pid_handle,</span><br><span class="line">        kernel_stack,</span><br><span class="line">        inner: <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            UPSafeCell::<span class="title function_ invoke__">new</span>(TaskControlBlockInner &#123;</span><br><span class="line">                trap_cx_ppn,</span><br><span class="line">                base_size: parent_inner.base_size,</span><br><span class="line">                task_cx: TaskContext::<span class="title function_ invoke__">goto_trap_return</span>(kernel_stack_top),</span><br><span class="line">                task_status: TaskStatus::Ready,</span><br><span class="line">                memory_set,</span><br><span class="line">                parent: <span class="title function_ invoke__">Some</span>(Arc::<span class="title function_ invoke__">downgrade</span>(<span class="keyword">self</span>)),</span><br><span class="line">                children: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">                exit_code: <span class="number">0</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// add child</span></span><br><span class="line">    parent_inner.children.<span class="title function_ invoke__">push</span>(task_control_block.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="comment">// modify kernel_sp in trap_cx</span></span><br><span class="line">    <span class="comment">// **** access children PCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = task_control_block.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    trap_cx.kernel_sp = kernel_stack_top;</span><br><span class="line">    <span class="comment">// return</span></span><br><span class="line">    task_control_block</span><br><span class="line">    <span class="comment">// ---- release parent PCB automatically</span></span><br><span class="line">    <span class="comment">// **** release children PCB automatically</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-exec-的实现"><a href="#4-2-exec-的实现" class="headerlink" title="4.2 exec 的实现"></a>4.2 exec 的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exec</span>(path: *<span class="keyword">const</span> <span class="type">u8</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">token</span> = <span class="title function_ invoke__">current_user_token</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">path</span> = <span class="title function_ invoke__">translated_str</span>(token, path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 path 拿到 app 的数据，</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(data) = <span class="title function_ invoke__">get_app_data_by_name</span>(path.<span class="title function_ invoke__">as_str</span>()) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">task</span> = <span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        task.<span class="title function_ invoke__">exec</span>(data);</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">exec</span>(&amp;<span class="keyword">self</span>, elf_data: &amp;[<span class="type">u8</span>]) &#123;</span><br><span class="line">    <span class="comment">// memory_set with elf program headers/trampoline/trap context/user stack</span></span><br><span class="line">    <span class="keyword">let</span> (memory_set, user_sp, entry_point) = MemorySet::<span class="title function_ invoke__">from_elf</span>(elf_data);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx_ppn</span> = memory_set</span><br><span class="line">        .<span class="title function_ invoke__">translate</span>(VirtAddr::<span class="title function_ invoke__">from</span>(TRAP_CONTEXT).<span class="title function_ invoke__">into</span>())</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>()</span><br><span class="line">        .<span class="title function_ invoke__">ppn</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// **** access inner exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line">    <span class="comment">// substitute memory_set</span></span><br><span class="line">    inner.memory_set = memory_set;</span><br><span class="line">    <span class="comment">// update trap_cx ppn</span></span><br><span class="line">    inner.trap_cx_ppn = trap_cx_ppn;</span><br><span class="line">    <span class="comment">// initialize base_size</span></span><br><span class="line">    inner.base_size = user_sp;</span><br><span class="line">    <span class="comment">// initialize trap_cx</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">trap_cx</span> = inner.<span class="title function_ invoke__">get_trap_cx</span>();</span><br><span class="line">    *trap_cx = TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        entry_point,</span><br><span class="line">        user_sp,</span><br><span class="line">        KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">token</span>(),</span><br><span class="line">        <span class="keyword">self</span>.kernel_stack.<span class="title function_ invoke__">get_top</span>(),</span><br><span class="line">        trap_handler <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// **** release inner automatically</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-waitpid-的实现"><a href="#4-3-waitpid-的实现" class="headerlink" title="4.3 waitpid 的实现"></a>4.3 waitpid 的实现</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// If there is not a child process whose pid is same as given, return -1.</span></span><br><span class="line"><span class="comment">/// Else if there is a child process but it is still running, return -2.</span></span><br><span class="line">                <span class="comment">// pid 我要等待子进程的 pid，exit_code_ptr 子进程的返回值</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_waitpid</span>(pid: <span class="type">isize</span>, exit_code_ptr: *<span class="keyword">mut</span> <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = <span class="title function_ invoke__">current_task</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="comment">// find a child process</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- access current TCB exclusively</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = task.<span class="title function_ invoke__">inner_exclusive_access</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先去偏历 children 的成员变量，找 pid 和它一样的。</span></span><br><span class="line">    <span class="keyword">if</span> !inner</span><br><span class="line">        .children</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">any</span>(|p| pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="type">usize</span> == p.<span class="title function_ invoke__">getpid</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有就退出。</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// ---- release current PCB</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// is_zombie 看这个进程是否是退出状态。</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pair</span> = inner.children.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>().<span class="title function_ invoke__">find</span>(|(_, p)| &#123;</span><br><span class="line">        <span class="comment">// ++++ temporarily access child PCB lock exclusively</span></span><br><span class="line">        p.<span class="title function_ invoke__">inner_exclusive_access</span>().<span class="title function_ invoke__">is_zombie</span>() &amp;&amp; (pid == -<span class="number">1</span> || pid <span class="keyword">as</span> <span class="type">usize</span> == p.<span class="title function_ invoke__">getpid</span>())</span><br><span class="line">        <span class="comment">// ++++ release child PCB</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((idx, _)) = pair &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">child</span> = inner.children.<span class="title function_ invoke__">remove</span>(idx);</span><br><span class="line">        <span class="comment">// confirm that child will be deallocated after removing from children list</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(Arc::<span class="title function_ invoke__">strong_count</span>(&amp;child), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">found_pid</span> = child.<span class="title function_ invoke__">getpid</span>();</span><br><span class="line">        <span class="comment">// ++++ temporarily access child TCB exclusively</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取返回码。</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">exit_code</span> = child.<span class="title function_ invoke__">inner_exclusive_access</span>().exit_code;</span><br><span class="line">        <span class="comment">// ++++ release child PCB</span></span><br><span class="line">        *<span class="title function_ invoke__">translated_refmut</span>(inner.memory_set.<span class="title function_ invoke__">token</span>(), exit_code_ptr) = exit_code;</span><br><span class="line">        found_pid <span class="keyword">as</span> <span class="type">isize</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        -<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ---- release current PCB lock automatically</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://goversion.github.io/2025/08/31/os4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhou tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/31/os4/" class="post-title-link" itemprop="url">os4</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-31 17:44:24 / 修改时间：17:45:54" itemprop="dateCreated datePublished" datetime="2025-08-31T17:44:24+08:00">2025-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OS-第四章：地址空间的抽象-—-从-va-到-pa"><a href="#OS-第四章：地址空间的抽象-—-从-va-到-pa" class="headerlink" title="OS 第四章：地址空间的抽象 —- 从 va 到 pa"></a>OS 第四章：地址空间的抽象 —- 从 va 到 pa</h1><p>回顾分时系统，每个 app 要和 kernel 约好地址空间，每一个 app 地址都是事先写死的，这就存在诸多不便。于是引入对地址空间的抽象—-虚拟地址。</p>
<p>本章原理上比较简单，但在代码实现上颇有难度，是学习 OS 路上的一道槛。一方面，需要做一些铺垫性的准备工作，另一方面，正式的功能步骤也比较多，下面按功能分解如下：</p>
<ul>
<li>第一个准备工作—-动态分配。因为 rust 没有标准库的支持，缺少在 heap 上对内存动态分配的功能，该功能需要补上，rust 才能正常使用一些  heap 上对内存动态分配的数据结构。</li>
<li>第二个准备工作—-物理页帧管理。</li>
<li>第三个准备工作—-CPU 为页表做的硬件准备 MMU,TLB</li>
<li>正式四步之第一步—-映射管理。管理 <code>(ekernel 0x80000000, MEMORY_END 0x80800000)</code> 区间的内存。</li>
<li>正式四步之第二步—-把内核映射起来。</li>
<li>正式四步之第三步—-把应用映射起来。</li>
<li>正式四步之第四步—-切换的问题。</li>
</ul>
<p>TODO:</p>
<ul>
<li>把数据结构的宏观图画出来。</li>
<li>阅读源代码。</li>
<li>单步调试。</li>
<li>查一下RAII 思想的相关背景？<blockquote>
<p>将某种资源的生命周期与一个变量绑定的这种 RAII 的思想无处不在。</p>
</blockquote>
</li>
</ul>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/528896132">https://zhuanlan.zhihu.com/p/528896132</a></li>
<li><a target="_blank" rel="noopener" href="https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html">https://hangx-ma.github.io/2023/07/04/rcore-note-ch4.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/YuanZiming/p/14561382.html">https://www.cnblogs.com/YuanZiming/p/14561382.html</a></li>
</ul>
<h2 id="0-总览"><a href="#0-总览" class="headerlink" title="0 总览"></a>0 总览</h2><p><img src="/./pics/4_13.png"></p>
<h2 id="1-第一个准备工作—-动态分配"><a href="#1-第一个准备工作—-动态分配" class="headerlink" title="1 第一个准备工作—-动态分配"></a>1 第一个准备工作—-动态分配</h2><p>因为此时 kernel 运行在 no_std 环境下，并没有动态内存分配的功能，此时，就需要我们自己实现<code>动态内存分配器</code>。在内核最开始的镜像中定义了一个较大的静态内存区域，我们对这片区域进行一个动态管理。rust 的一些  Box &#x2F; Vec &#x2F;BTreeMap &#x2F; alloc 库的大多数数据结构需要堆的支持。有了<code>动态内存分配器</code>，rust 的这些数据结构才会正常工作。</p>
<p>rust 有 treat</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">alloc</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">dealloc</span></span><br></pre></td></tr></table></figure>

<p>我们只需要加上定义全局的，实现了全局接口的数据结构。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>看 rcore kernel 初始化堆的代码：</p>
<p>看 main.rs mm::init() -&gt; mod.rs init() -&gt; heap_allocator::init_heap()</p>
<h4 id="1-1-具体编程实现"><a href="#1-1-具体编程实现" class="headerlink" title="1.1 具体编程实现"></a>1.1 具体编程实现</h4><p>在上一章的代码基础上添加下面内容。</p>
<ul>
<li><p>在 os&#x2F;Cargo.toml 中引入:<br>buddy_system_allocator &#x3D; “0.6”</p>
</li>
<li><p>在os&#x2F;src&#x2F;main.rs中引入.</p>
</li>
</ul>
<p>extern crate alloc;</p>
<ul>
<li>创建 os&#x2F;src&#x2F;mm&#x2F;heap_allocator.rs</li>
</ul>
<p>alloc 库需要我们提供给它一个<code>全局的动态内存分配器</code>，它会利用该分配器来管理堆空间，从而使得与堆相关的智能指针或容器数据结构可以正常工作。具体而言，我们的<code>动态内存分配器</code>需要实现它提供的 GlobalAlloc Trait。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> buddy_system_allocator::LockedHeap;</span><br><span class="line"><span class="keyword">use</span> crate::config::KERNEL_HEAP_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[global_allocator]</span></span><br><span class="line"><span class="keyword">static</span> HEAP_ALLOCATOR: LockedHeap = LockedHeap::<span class="title function_ invoke__">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> HEAP_SPACE: [<span class="type">u8</span>; KERNEL_HEAP_SIZE] = [<span class="number">0</span>; KERNEL_HEAP_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_heap</span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP_ALLOCATOR</span><br><span class="line">            .<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, KERNEL_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[alloc_error_handler]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_alloc_error</span>(layout: core::alloc::Layout) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Heap allocation error, layout = &#123;:?&#125;&quot;</span>, layout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建测试函数</span></span><br><span class="line"><span class="meta">#[allow(unused)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">heap_test</span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> alloc::boxed::<span class="type">Box</span>;</span><br><span class="line">    <span class="keyword">use</span> alloc::vec::<span class="type">Vec</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bss_range</span> = sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="type">Box</span>::<span class="title function_ invoke__">new</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(*a, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">assert!</span>(bss_range.<span class="title function_ invoke__">contains</span>(&amp;(a.<span class="title function_ invoke__">as_ref</span>() <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;<span class="type">usize</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">500</span> &#123;</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">500</span> &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(v[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert!</span>(bss_range.<span class="title function_ invoke__">contains</span>(&amp;(v.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>)));</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(v);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;heap_test passed!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert_eq!(*a, 5);</span><br><span class="line">assert!(bss_range.contains(&amp;(a.as_ref() as *const _ as usize)));</span><br></pre></td></tr></table></figure>
<p>判断a的值是否为5</p>
<p>判断a的指针是否在bss的范围内</p>
<p>接下来的操作则是创建了一个Vec容器，然后储存了0..500的值进去，并且分别执行上述对a的断言判断。</p>
<h2 id="2-第二个准备工作—-CPU-为页表做的硬件准备-MMU-TLB"><a href="#2-第二个准备工作—-CPU-为页表做的硬件准备-MMU-TLB" class="headerlink" title="2 第二个准备工作—-CPU 为页表做的硬件准备 MMU,TLB"></a>2 第二个准备工作—-CPU 为页表做的硬件准备 MMU,TLB</h2><h4 id="2-1-三级页表"><a href="#2-1-三级页表" class="headerlink" title="2.1 三级页表"></a>2.1 三级页表</h4><p>由于虚拟页号有 $2^{39-12&#x3D;27}$ 种，每个页表项使用 8 字节，则每个页表需要消耗掉 $ 2^{27} * 8 &#x3D; 2^{30} &#x3D; 1GB $ 内存！这显然不可行。</p>
<p>多级页表的设计类似于数据结构中的字典树，使用 3 个 9 位的页号分段进行索引。</p>
<p><code>aaaaaaaaa bbbbbbbbb ccccccccc</code></p>
<p>使用 aaaaaaaaa 在根页表中查到对应的物理地址 A ，在 A 处的二级页表中查询 bbbbbbbbb ，以此类推，直到查询到叶子节点。</p>
<h4 id="2-2-CPU-为页表做的硬件准备—-MMU-TLB"><a href="#2-2-CPU-为页表做的硬件准备—-MMU-TLB" class="headerlink" title="2.2 CPU 为页表做的硬件准备—-MMU, TLB"></a>2.2 CPU 为页表做的硬件准备—-MMU, TLB</h4><p>前面两章，app 在编写时是写死的，kernel 在加载 app 也需要按约定的地址加载。</p>
<p>有了地址空间的抽象，需要两个硬件的辅助：</p>
<ol>
<li>MMU: memory management unit：它的功能是将 虚拟地址 -&gt; 物理地址。<br>为每个 app 做转换，<br>硬件提供一些 register，软件可以对 register 进设置，来控制 MMU 当前为哪个应用的转换规则。</li>
</ol>
<p>有了 mmu ，硬件帮我们做转换，每次做转换，每次需读内存，为了进一步降低开销，CPU 还提供了 TLB。</p>
<ol start="2">
<li>TLB: translation lookaside buffer 快表，<code>TLB 就是一张表</code>，是 mmu 在 CPU 上的一个 cache。<ul>
<li><p>存储 virtual address -&gt; physical address 的转换关系。<br> 当 MMU 做了一次转换之后，TLB 就把这个转换关系存在自己的表里。<br> 当下次需要使用时，直接先在 TLB 里查找，如果命中则结束。如果没有找到，则需要到 MMU 里找。</p>
</li>
<li><p>当切换到不同 app 时，TLB 是需要清空的，</p>
</li>
</ul>
</li>
</ol>
<h4 id="2-3-上面有了概念，硬件为‘映射’做了哪些事呢？"><a href="#2-3-上面有了概念，硬件为‘映射’做了哪些事呢？" class="headerlink" title="2.3 上面有了概念，硬件为‘映射’做了哪些事呢？"></a>2.3 上面有了概念，硬件为‘映射’做了哪些事呢？</h4><blockquote>
<p>SV39 仅仅使用低39位，高25位必须与第38位保持一致，才能通过MMU的检查（硬件实现），换句话说，只有 0 —— 0000003FFFFFFFFF（低256GB）和 FFFFFC000000000 —— FFFFFFFFFFFFFFFF（高256G）才能通过MMU检查。</p>
</blockquote>
<blockquote>
<blockquote>
<p>这里，对 “ 高25位必须与第38位保持一致 ” 不理解?</p>
</blockquote>
</blockquote>
<p>如何从 39 的<code>虚拟地址</code>转换到<code>物理地址</code>的？</p>
<p><img src="/./pics/4_04.png"></p>
<ul>
<li>虚拟地址被分为39位，意味着虚拟地址空间的可以达到$2^{39}&#x3D;512GB$。其中低12位是页内的偏移量, 高27位可以分为3份, 每份9位, 表示的是在各级页表中的索引。</li>
<li>物理地址的低12位表示一个页内的偏移, 12-55位表示了页号。</li>
</ul>
<p><img src="/./pics/4_05.png"></p>
<p>注意上图，L2&#x2F;L1&#x2F;L0 都是索引，是索引，是索引。</p>
<blockquote>
<p>疑问：39 位的 va 映射为 44 的 pa，是不是有点毛病？</p>
</blockquote>
<h2 id="3-第三个准备工作—-物理页帧分配器-StackFrameAllocator"><a href="#3-第三个准备工作—-物理页帧分配器-StackFrameAllocator" class="headerlink" title="3 第三个准备工作—-物理页帧分配器 StackFrameAllocator"></a>3 第三个准备工作—-物理页帧分配器 StackFrameAllocator</h2><ul>
<li>物理内存的范围是什么？</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">  -machine virt \</span><br><span class="line">  -machine dumpdtb=qemu.dtb \</span><br><span class="line">  -nographic \</span><br><span class="line">  -bios ../../rustsbi-qemu.bin \</span><br><span class="line">  -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span><br><span class="line"></span><br><span class="line">dtc -I dtb -O dts qemu.dtb &gt; qemu.dts</span><br></pre></td></tr></table></figure>
<p>我们可以看到 qemu-system-riscv64 模拟出的计算机，它的内存是 128M。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">memory@80000000 &#123;</span><br><span class="line">    device_type = &quot;memory&quot;;</span><br><span class="line">    reg = &lt;0x00 0x80000000 0x00 0x8000000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>src&#x2F;mm&#x2F;frame_allocator.rs<br>开启分页后，首先把物理内存管理起来，管理的对象是内核空间以外的物理空间。<br>先找到了 <code>ekernel 的最后的地址</code>，到 MEMORY_END 之间都当作空闲的页进行管理。</p>
<p>rCore 使用了最简单的<code>栈式物理页帧管理策略</code> struct StackFrameAllocator 实现 FRAME_ALLOCATOR， 并开放给其他内核模块两个用以分配和回收物理地址 frame 的接口： frame_alloc 以及 frame_dealloc。 值得注意的是 frame_alloc 返回的类型是封装 PhysPageNum 的 FrameTracker 类型， 该类型实现了 Drop Trait， 这是一种 RAII 的思想， 当 FrameTracker 的声明周期结束， 其包裹的 PhysPageNum 能通过编译器自动回收到 FRAME_ALLOCATOR。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_frame_allocator</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ekernel</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    FRAME_ALLOCATOR.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">init</span>(</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">ceil</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(MEMORY_END).<span class="title function_ invoke__">floor</span>(),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让内核能访问实际的物理地址， rCore 设计了三种粒度的访问方式： 基于 PTE， 基于 Bytes， 基于变量类型。 至此， 物理地址空间的分配以及访问的框架已经建成， 后续需要做的就是构建虚拟地址与物理地址映射的 页表(Page Table)。</p>
<h2 id="4-正式四步之第一步—-空间抽象的数据结构-PageTable-MapArea-MemorySet"><a href="#4-正式四步之第一步—-空间抽象的数据结构-PageTable-MapArea-MemorySet" class="headerlink" title="4 正式四步之第一步—-空间抽象的数据结构 PageTable &#x2F; MapArea &#x2F; MemorySet"></a>4 正式四步之第一步—-空间抽象的数据结构 PageTable &#x2F; MapArea &#x2F; MemorySet</h2><h4 id="4-1-页表-Page-Table"><a href="#4-1-页表-Page-Table" class="headerlink" title="4.1 页表 Page Table"></a>4.1 页表 Page Table</h4><p>上面把物理页管理起来了，现在开始构建结构 PageTable，它负责建立好 va 到 pa 的关系，逐步建立好<code>三级页表</code>的过程。<br>PageTable 的数据结构的设计包括了定位 Page Table 的 root_ppn 以及 Page Table 中包含的各个 PTE 项 frames。<br>因此 struct PageTable 初始化的流程就很自然能想得出，每个 PageTable 都需要向 frame allocator 先申请一个物理页帧将其 PPN 作为 root_ppn 唯一标识。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// page table structure</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    root_ppn: PhysPageNum,</span><br><span class="line">    frames: <span class="type">Vec</span>&lt;FrameTracker&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>root_ppn 保存根节点的物理页号，它作为<code>页表唯一的区分标志</code>。</p>
<p>frames 保存了页表所有的节点(包括根节点) 所在的物理页帧。(<code>RAII</code> 自动回收所有物理页帧)</p>
<p>并且，它为 PageTable 这个结构实现了两个函数，map 和 unmap。map 建立映射表，unmap 就是回收映射表。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags);</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>估计是为了让 root_ppn 和 frames 的指向和含义统一才把 PTE 命名为 frame， 个人感觉直接用 PTE 会清晰很多。 这里 rCore 又提及 RAII 的思想， frames 内部变量通过 Vec 数据结构绑定 FrameTracker， 可以保证声明周期结束后对 FrameTracker 的内存自动回收。</p>
</blockquote>
<blockquote>
<p>什么是节点？</p>
</blockquote>
<h4 id="4-2-建立-VA-与-PA-的映射关系"><a href="#4-2-建立-VA-与-PA-的映射关系" class="headerlink" title="4.2 建立 VA 与 PA 的映射关系"></a>4.2 建立 VA 与 PA 的映射关系</h4><p>Page Table 必然是动态变化的， 程序运行的时候会通过 <code>Page Fault Trap</code> 来实现对内存页的按需分配。 当我们知道虚拟地址空间的某个 VA 的时候， 需要通过前述的 Page Table 找到或建立一个关于物理页帧映射。rCore 提供了两个基础函数 <code>find_pte_create</code> 以及 <code>find_pte</code>， 区别就在于是否在某一级页表的 PTE 未创建时创建一个新的 PTE。</p>
<p>用 map&#x2F;unmap 为当前的 Page Table 增加或删除 PTE。</p>
<p>find_pte_create：实现 map 时，发现有些页表不存在，就申请一个物理页，再建立映射。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PageTable</span> &#123;</span><br><span class="line">    <span class="comment">/// Find PageTableEntry by VirtPageNum, create a frame for a 4KB page table if not exist</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte_create</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="comment">// 发现一个 pte 不存在，就新建一个物理页，</span></span><br><span class="line">                <span class="keyword">let</span> <span class="variable">frame</span> = <span class="title function_ invoke__">frame_alloc</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(frame.ppn, PTEFlags::V);</span><br><span class="line">                <span class="keyword">self</span>.frames.<span class="title function_ invoke__">push</span>(frame);</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// Find PageTableEntry by VirtPageNum</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">find_pte</span>(&amp;<span class="keyword">self</span>, vpn: VirtPageNum) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">idxs</span> = vpn.<span class="title function_ invoke__">indexes</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ppn</span> = <span class="keyword">self</span>.root_ppn;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">result</span>: <span class="type">Option</span>&lt;&amp;<span class="keyword">mut</span> PageTableEntry&gt; = <span class="literal">None</span>;</span><br><span class="line">        <span class="keyword">for</span> (i, idx) <span class="keyword">in</span> idxs.<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">pte</span> = &amp;<span class="keyword">mut</span> ppn.<span class="title function_ invoke__">get_pte_array</span>()[*idx];</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">2</span> &#123;</span><br><span class="line">                result = <span class="title function_ invoke__">Some</span>(pte);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !pte.<span class="title function_ invoke__">is_valid</span>() &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ppn = pte.<span class="title function_ invoke__">ppn</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// set the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">map</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum, ppn: PhysPageNum, flags: PTEFlags) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span>: &amp;<span class="keyword">mut</span> PageTableEntry = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte_create</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(!pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is mapped before mapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">new</span>(ppn, flags | PTEFlags::V);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// remove the map between virtual page number and physical page number</span></span><br><span class="line">    <span class="meta">#[allow(unused)]</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">unmap</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, vpn: VirtPageNum) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pte</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_pte</span>(vpn).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(pte.<span class="title function_ invoke__">is_valid</span>(), <span class="string">&quot;vpn &#123;:?&#125; is invalid before unmapping&quot;</span>, vpn);</span><br><span class="line">        *pte = PageTableEntry::<span class="title function_ invoke__">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一些辅助函数，把物理页转换成数组。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">PhysPageNum</span> &#123;</span><br><span class="line">    <span class="comment">/// Get the reference of page table(array of ptes)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">get_pte_array</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;static</span> <span class="keyword">mut</span> [PageTableEntry] &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pa</span>: PhysAddr = (*<span class="keyword">self</span>).<span class="title function_ invoke__">into</span>();</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(pa.<span class="number">0</span> <span class="keyword">as</span> *<span class="keyword">mut</span> PageTableEntry, <span class="number">512</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>PageTable 只能以页为单位维护 virtual -&gt; physical 映射表，对计算机系统的整个 虚拟&#x2F;物理 的空间并没有一个全局的描述和掌握。</p>
<blockquote>
<p>这一段描述，我仍然不是很理解。PageTable 是维护一个 app 的 (v, p) 映射表吗？还是? 这里理解得不透。</p>
</blockquote>
<blockquote>
<p>老师在讲，有了 pageTable ，为什么还需要 MapArea &#x2F; MemorySet? 这个思路没有讲清楚。</p>
</blockquote>
<blockquote>
<blockquote>
<p>pageTable 是维护一个页的映射，MapArea 是维护一段连续的映射。</p>
</blockquote>
</blockquote>
<ul>
<li>那么 VirtAddr 是如何转换为 PhysPageNum 的呢？</li>
</ul>
<p>VirtAddr -&gt; 调用 VirtAddr::into() 转换为 VirtPageNum -&gt; 用 page_table 的 translate 方法获取 PageTableEntry -&gt; 调用 PageTableEntry::ppn() 获取 PhysPageNum。</p>
<h4 id="4-3-地址空间的管理-MapArea-MemorySet"><a href="#4-3-地址空间的管理-MapArea-MemorySet" class="headerlink" title="4.3 地址空间的管理  MapArea &#x2F; MemorySet"></a>4.3 地址空间的管理  MapArea &#x2F; MemorySet</h4><p>为了对整个 虚拟&#x2F;物理 的空间有一个全局的描述，我们需要进一步抽象。</p>
<p>使用 sruct MapArea 表示一段连续地址的虚拟内存，所有虚拟页面都以相同的方式映射到物理页帧，而 PageTable <code>只维护以页为大小的转换关系</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub struct MapArea &#123;</span><br><span class="line">    vpn_range: VPNRange,</span><br><span class="line">    data_frames: BTreeMap&lt;VirtPageNum, FrameTracker&gt;,</span><br><span class="line">    map_type: MapType,      //</span><br><span class="line">    map_perm: MapPermission,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>vpn_range: 表明该逻辑段的在虚拟地址的范围以及长度；</li>
<li>data_frames: 既然区分了映射方式， 存储映射关系的数据结构也会不同，data_frames 用于存储 leaf PTE 的 PPN 与其对应的 VPN 之间的关系，仅用在 Framed 映射办法；</li>
<li>map_type: 则表示了虚拟地址和物理地址的映射办法，直接映射 (MapType::Identical) 又或是通过 FRAME_ALLOCATOR 随机分配物理帧 (MapType::Framed)；</li>
<li>map_perm: 就和 Linux 系统的 RWXU 的含义基本接近了；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pub struct MemorySet &#123;</span><br><span class="line">    page_table: PageTable,</span><br><span class="line">    areas: Vec&lt;MapArea&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把所有的 MapArea 和 PageTable 都管理起来，</p>
<p>也就是说，<code>地址空间</code>的实现是通过三个结构 MemorySet、PageTable、MapArea。</p>
<p><img src="/./pics/4_02.jpg"></p>
<p><code>readelf  -a  target/riscv64gc-unknown-none-elf/release/os  | less</code></p>
<p><img src="/./pics/4_09.png"></p>
<p>MemorySet、PageTable、MapArea 就是上图数据的结构体。</p>
<p>如上图，MemorySet 描述多个段，MapArea 是用来描述一个段的概念，它包括多个 frame。</p>
<p><img src="/./pics/4_06.png"></p>
<h2 id="5-正式四步之第二步—-把内核映射起来。-开启分页模式的虚拟地址空间，为内核建立恒等映射"><a href="#5-正式四步之第二步—-把内核映射起来。-开启分页模式的虚拟地址空间，为内核建立恒等映射" class="headerlink" title="5 正式四步之第二步—-把内核映射起来。(开启分页模式的虚拟地址空间，为内核建立恒等映射)"></a>5 正式四步之第二步—-把内核映射起来。(开启分页模式的虚拟地址空间，为内核建立恒等映射)</h2><p><img src="/./pics/4_07.png"></p>
<p><img src="/./pics/4_08.png"></p>
<p><img src="/./pics/4_11.png"></p>
<p><font color="red">为什么这个 trampoline 在 .text 区域放着？ .text 不是低地址吗，trampoline 不是在高地址吗？</font></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    <span class="comment">/// The kernel&#x27;s initial memory mapping(kernel address space)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> KERNEL_SPACE: Arc&lt;UPSafeCell&lt;MemorySet&gt;&gt; =</span><br><span class="line">        Arc::<span class="title function_ invoke__">new</span>(<span class="keyword">unsafe</span> &#123; UPSafeCell::<span class="title function_ invoke__">new</span>(MemorySet::<span class="title function_ invoke__">new_kernel</span>()) &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Without kernel stacks.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new_kernel</span>() <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">memory_set</span> = <span class="keyword">Self</span>::<span class="title function_ invoke__">new_bare</span>();</span><br><span class="line">    <span class="comment">// map trampoline</span></span><br><span class="line">    memory_set.<span class="title function_ invoke__">map_trampoline</span>();</span><br><span class="line">    <span class="comment">// map kernel sections</span></span><br><span class="line">    info!(<span class="string">&quot;.text [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, stext <span class="keyword">as</span> <span class="type">usize</span>, etext <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.rodata [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, srodata <span class="keyword">as</span> <span class="type">usize</span>, erodata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(<span class="string">&quot;.data [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>, sdata <span class="keyword">as</span> <span class="type">usize</span>, edata <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    info!(</span><br><span class="line">        <span class="string">&quot;.bss [&#123;:#x&#125;, &#123;:#x&#125;)&quot;</span>,</span><br><span class="line">        sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>, ebss <span class="keyword">as</span> <span class="type">usize</span></span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .text section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (stext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (etext <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::X,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .rodata section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (srodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (erodata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .data section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sdata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (edata <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping .bss section&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (sbss_with_stack <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            (ebss <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    info!(<span class="string">&quot;mapping physical memory&quot;</span>);</span><br><span class="line">    memory_set.<span class="title function_ invoke__">push</span>(</span><br><span class="line">        MapArea::<span class="title function_ invoke__">new</span>(</span><br><span class="line">            (ekernel <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MEMORY_END.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">            MapType::Identical,</span><br><span class="line">            MapPermission::R | MapPermission::W,</span><br><span class="line">        ),</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">    );</span><br><span class="line">    memory_set</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// os/src/trap/trap.S</span><br><span class="line">    .section .text.trampoline</span><br><span class="line">    .globl __alltraps</span><br><span class="line">    .globl __restore</span><br><span class="line">    .align 2</span><br><span class="line">__alltraps:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">__restore:</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从linker-qemu.ld和trap.S中可以看出，物理地址在strampoline的代码段是中断和异常处理入口和恢复的出口。我们通过map_trampoline方法把这部分映射到了内核地址空间的最高处。</p>
<p>然后调用 <code>rust_main() -&gt; mm::init() -&gt; KERNEL_SPACE.exclusive_access().activate()</code> 内核就开启了使用 va 访问内存。</p>
<p>到此为止mm::init就做了这些事情，算是把内核空间给搞定了，仔细想想，虽然用起来没啥差别，因为做了一个恒等映射，之间访问到哪儿，现在还是访问到哪儿，但其中的过程却是大不相同，在访存的时候不是一开始拿着地址就当作物理地址访问，而是通过MMU翻译之后得到物理地址，只是说翻译了一通最后发现等于一开始拿到的虚拟地址，虽说过程曲折，但结果倒是一样。</p>
<h2 id="6-正式四步之第三步—-把应用映射起来。"><a href="#6-正式四步之第三步—-把应用映射起来。" class="headerlink" title="6 正式四步之第三步—-把应用映射起来。"></a>6 正式四步之第三步—-把应用映射起来。</h2><h2 id="7-正式四步之第四步—-trapContext-切换的问题。"><a href="#7-正式四步之第四步—-trapContext-切换的问题。" class="headerlink" title="7 正式四步之第四步—-trapContext 切换的问题。"></a>7 正式四步之第四步—-trapContext 切换的问题。</h2><p>u-s 之间的跳转就没有之前那么简单了，之前都是 pa 地址空间，现在，各在各的空间，要在两个空间之间做跳转。</p>
<p>值得注意的是无论是内核空间还是应用程序空间，在最高的虚拟页上，我们设置了一个 <code>trampoline</code> ，在转换时，这一段地址都会映射到相同的地址。这样就保证了在映射前后，执行的指令是连续的。</p>
<p>在地址空间进行切换的时候，会有一段代码，既需要在用户空间访问，也需要在内核空间访问。</p>
<p>再看<code>用户地址空间</code>的次高页，有了 trapContext，这个之前是放在内核栈里的，</p>
<h4 id="7-1-为什么要把-trapContext-放在用户空间？"><a href="#7-1-为什么要把-trapContext-放在用户空间？" class="headerlink" title="7.1 为什么要把 trapContext 放在用户空间？"></a>7.1 为什么要把 trapContext 放在用户空间？</h4><p>如果放在内核空间，需要两个寄存器，一个用于保存内核页表指针，一个内核栈顶。硬件却只提供一个 sscratch 可以用来进行周转。</p>
<blockquote>
<p>内核空间的 token 是什么？</p>
</blockquote>
<blockquote>
<p>内核空间是 identical 了，用户对kernel 空间的布局都清楚了，还需要内核页表做什么？</p>
</blockquote>
<p>引入虚拟内存后, 需要添加地址空间MemorySet的结构体以及每个任务的trap context的物理页号, 这样以来, 内核才可以在任务控制时获取其trap的上下文信息</p>
<p><img src="/./pics/4_01.jpg"></p>
<p><img src="/./pics/a2bbc8ee.webp"></p>
<h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h2><ul>
<li>mm::init()</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先分配堆</span></span><br><span class="line">    heap_allocator::<span class="title function_ invoke__">init_heap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 物理页帧分配器</span></span><br><span class="line">    frame_allocator::<span class="title function_ invoke__">init_frame_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先按排内核地址， activate 往 satp 里写值，激活内核的分页。</span></span><br><span class="line">    KERNEL_SPACE.<span class="title function_ invoke__">exclusive_access</span>().<span class="title function_ invoke__">activate</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">map_trampoline</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.page_table.<span class="title function_ invoke__">map</span></span><br><span class="line">    (</span><br><span class="line">        VirtAddr::<span class="title function_ invoke__">from</span>(TRAMPOLINE).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PhysAddr::<span class="title function_ invoke__">from</span>(strampoline <span class="keyword">as</span> <span class="type">usize</span>).<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        PTEFlags::R | PTEFlags::X,</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里就表示，从内存的顶端往下一个页面。</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">const</span> TRAMPOLINE: <span class="type">usize</span> = <span class="type">usize</span>::MAX - PAGE_SIZE + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所以虚拟地址的内核页里，trampline 的代码有两份，一份在 text 里，一份在 trampline 里，它们指向同一个物理页面。</p>
<ul>
<li>task::run_first_task()</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_first_task</span>()</span><br><span class="line">&#123;</span><br><span class="line">    TASK_MANAGER.<span class="title function_ invoke__">run_first_task</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./pics/4_12.png"><br><img src="/./pics/4_13.png"></p>
<p><font color="red">下面的 alltraps 代码涉及到三个栈指针 sp，首先 <code>csrrw sp, sscratch, sp</code> 使得当前的 sp 指向 trapcontext 结构，scratch 指向 user stack。</p>
<p>然后 <code>ld sp, 35*8(sp)</code> 一行，对照着 TrapContext 结构 的 offset 35，即 sp 指向了 app kernel stack。</p>
<p>接着，切换页表，执行一个长跳转 <code>jr t1</code> 跳到 traphandler， traphandler 位于低地址，trampoline 位于高地址，所以这里是长跳转。<br></font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;*TrapContext in user space, sscratch-&gt;user stack</span><br><span class="line">    # save other general purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they have been saved in TrapContext</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it in TrapContext</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # load kernel_satp into t0</span><br><span class="line">    ld t0, 34*8(sp)</span><br><span class="line">    # load trap_handler into t1</span><br><span class="line">    ld t1, 36*8(sp)</span><br><span class="line">    # move to kernel_sp</span><br><span class="line">    ld sp, 35*8(sp)</span><br><span class="line">    # switch to kernel space</span><br><span class="line">    csrw satp, t0</span><br><span class="line">    sfence.vma</span><br><span class="line">    # jump to trap_handler</span><br><span class="line">    jr t1</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// General-Purpose Register x0-31</span></span><br><span class="line">    <span class="keyword">pub</span> x: [<span class="type">usize</span>; <span class="number">32</span>],</span><br><span class="line">    <span class="comment">/// Supervisor Status Register</span></span><br><span class="line">    <span class="keyword">pub</span> sstatus: Sstatus,</span><br><span class="line">    <span class="comment">/// Supervisor Exception Program Counter</span></span><br><span class="line">    <span class="keyword">pub</span> sepc: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Token of kernel address space</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_satp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Kernel stack pointer of the current application</span></span><br><span class="line">    <span class="keyword">pub</span> kernel_sp: <span class="type">usize</span>,</span><br><span class="line">    <span class="comment">/// Virtual address of trap handler entry point in kernel</span></span><br><span class="line">    <span class="keyword">pub</span> trap_handler: <span class="type">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TODO-gpb-时，遇到一个奇怪的现象。"><a href="#TODO-gpb-时，遇到一个奇怪的现象。" class="headerlink" title="TODO gpb 时，遇到一个奇怪的现象。"></a>TODO gpb 时，遇到一个奇怪的现象。</h2><p><img src="/./pics/4_10.png"></p>
<p>如上图所示，打了两个断点，分别是 run_first_task &#x2F; run_next_task，通过 gdb 进入的是 lazy_static 代码，有点不理解？</p>
<h2 id="TODO-待删，了解-from-raw-parts"><a href="#TODO-待删，了解-from-raw-parts" class="headerlink" title="TODO 待删，了解 from_raw_parts"></a>TODO 待删，了解 from_raw_parts</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">some_vector</span> = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pointer</span> = some_vector.<span class="title function_ invoke__">as_ptr</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">length</span> = some_vector.<span class="title function_ invoke__">len</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">my_slice</span>: &amp;[<span class="type">u32</span>] = slice::<span class="title function_ invoke__">from_raw_parts</span>(pointer, length);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(some_vector.<span class="title function_ invoke__">as_slice</span>(), my_slice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>接下来的任务是通读代码。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://goversion.github.io/2025/08/31/os3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhou tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/31/os3/" class="post-title-link" itemprop="url">os3</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-31 17:44:21 / 修改时间：17:45:38" itemprop="dateCreated datePublished" datetime="2025-08-31T17:44:21+08:00">2025-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OS-第三章：分时多任务系统"><a href="#OS-第三章：分时多任务系统" class="headerlink" title="OS 第三章：分时多任务系统"></a>OS 第三章：分时多任务系统</h1><p>分时多任务：</p>
<ul>
<li><p>任务上下文的切换；</p>
<ul>
<li>任务切换的时机；</li>
<li>任务上下文与 trap 上下文的区别；</li>
</ul>
</li>
<li><p>中断处理；</p>
</li>
<li><p>用户态 -&gt; 内核态</p>
<p>异常：即 syscall，用户程序主动调用 syscall 访问内核。</p>
<p>中断：如果用户程序访问 syscall 一直霸着 CPU 不放，用户程序虽然没有触发 syscall，但 kernel 可以主动中断用户程序。</p>
</li>
</ul>
<h2 id="0-总览"><a href="#0-总览" class="headerlink" title="0 总览"></a>0 总览</h2><p><img src="/./pics/3_05.png"></p>
<p><img src="/./pics/3_06.jpg"></p>
<p><img src="/./pics/3_08.png"></p>
<p>批处理系统：用户程序在用户态的瞬间状态(现场) A 用 trapContext 来封装。主控程序使用 <code>syscall / restore</code> 在用户态的 app 和内核态的 alltrap 之间来回跳动。</p>
<p><img src="/./pics/3_07.jpg"><br><font color="red"></p>
<p>分时系统：用户程序在内核态的瞬间状态 A‘ 用 taskContext 来封装。主控程序使用 <code>__switch</code> 在内核态里的 app 之间切换。</p>
<p>此处，该流程在脑海里像放动画一样，这个总结简洁而又高屋建瓴。<br></font></p>
<h2 id="1-从用户程序一侧的视角看"><a href="#1-从用户程序一侧的视角看" class="headerlink" title="1 从用户程序一侧的视角看"></a>1 从用户程序一侧的视角看</h2><p>从用户程序出发，因为内存足够大，把所有应用依次加载到各自的区域。而不是像前面，一次加载一个，每次加载到相同的区域。</p>
<p><img src="/./pics/3_05.png"></p>
<p>每个 app 会被编译到不同的起始处，对应地，load_app 也就需要改变。见 user&#x2F;build.py 代码里。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> app <span class="keyword">in</span> apps:</span><br><span class="line">    app = app[: app.find(<span class="string">&quot;.&quot;</span>)]</span><br><span class="line">    os.system(</span><br><span class="line">        <span class="string">&quot;cargo rustc --bin %s %s -- -Clink-args=-Ttext=%x&quot;</span></span><br><span class="line">        % (app, mode_arg, base_address + step * app_id)</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;[build.py] application %s start with address %s&quot;</span></span><br><span class="line">        % (app, <span class="built_in">hex</span>(base_address + step * app_id))</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> chapter == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        app_id = app_id + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>本章，每一个应用依次加载到 $ base_address + step * app_id &#x3D; 0x80400000 + 0x20000 * app_id $ 中。</p>
<p>在 kernel 侧，加载时就需要做相应的调整。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Load nth user app at</span></span><br><span class="line"><span class="comment">/// [APP_BASE_ADDRESS + n * APP_SIZE_LIMIT, APP_BASE_ADDRESS + (n+1) * APP_SIZE_LIMIT).</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">load_apps</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">_num_app</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app_ptr</span> = _num_app <span class="keyword">as</span> <span class="type">usize</span> <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app</span> = <span class="title function_ invoke__">get_num_app</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_start</span> = <span class="keyword">unsafe</span> &#123; core::slice::<span class="title function_ invoke__">from_raw_parts</span>(num_app_ptr.<span class="title function_ invoke__">add</span>(<span class="number">1</span>), num_app + <span class="number">1</span>) &#125;;</span><br><span class="line">    <span class="comment">// clear i-cache first</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load apps</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..num_app &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">base_i</span> = <span class="title function_ invoke__">get_base_i</span>(i);</span><br><span class="line">        <span class="comment">// clear region</span></span><br><span class="line">        (base_i..base_i + APP_SIZE_LIMIT)</span><br><span class="line">            .for_each(|addr| <span class="keyword">unsafe</span> &#123; (addr <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;);</span><br><span class="line">        <span class="comment">// load app from data section to memory</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">src</span> = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            core::slice::<span class="title function_ invoke__">from_raw_parts</span>(app_start[i] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, app_start[i + <span class="number">1</span>] - app_start[i])</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">dst</span> = <span class="keyword">unsafe</span> &#123; core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(base_i <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, src.<span class="title function_ invoke__">len</span>()) &#125;;</span><br><span class="line">        dst.<span class="title function_ invoke__">copy_from_slice</span>(src);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-用户程序主动交出控制权，引入了一个系统调用-sys-yield。"><a href="#2-用户程序主动交出控制权，引入了一个系统调用-sys-yield。" class="headerlink" title="2 用户程序主动交出控制权，引入了一个系统调用 sys_yield。"></a>2 用户程序主动交出控制权，引入了一个系统调用 sys_yield。</h2><p><img src="/./pics/3_03.png"></p>
<p>先把当前的 app 暂停下来，寻找下一个 app。然后通过 <code>__switch</code> 就完成了 “暂停上一下任务，切换到下一个任务” 的功能。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Switch current `Running` task to the task we have found,</span></span><br><span class="line"><span class="comment">/// or there is no `Ready` task and we can exit with all applications completed</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run_next_task</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(next) = <span class="keyword">self</span>.<span class="title function_ invoke__">find_next_task</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current</span> = inner.current_task;</span><br><span class="line">        inner.tasks[next].task_status = TaskStatus::Running;</span><br><span class="line">        inner.current_task = next;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">current_task_cx_ptr</span> = &amp;<span class="keyword">mut</span> inner.tasks[current].task_cx <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;inner.tasks[next].task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">        <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">        <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            __switch(current_task_cx_ptr, next_task_cx_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// go back to user mode</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1-TaskContext"><a href="#2-1-TaskContext" class="headerlink" title="2.1 TaskContext"></a>2.1 TaskContext</h4><p><img src="/./pics/3_01.jpg"></p>
<blockquote>
<p>为什么是在 kernel 时刻，做任务切换，在 kernel 从 A 切到 B，再 切到用户态 B。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pub struct TaskContext &#123;</span><br><span class="line">    /// Ret position after task switching</span><br><span class="line">    ra: usize,</span><br><span class="line">    /// Stack pointer</span><br><span class="line">    sp: usize,</span><br><span class="line">    /// s0-11 register, callee saved</span><br><span class="line">    s: [usize; 12],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>trapContext 跳到内核时，保存了 app 在用户态执行的状态，因为涉及到特权权的切换，它要保存大多数 Register。</p>
<p>从内核态跳到用户态时，app 就可以继续执行。也就是说，我们可以把程序的状态保存下来，并合适的时候恢复。</p>
<p>当 app 跳到 内核态，告诉内核，当前 app 可以暂停，<br>而 TaskContext，在程序</p>
<ul>
<li><p>trapContext 保存的是在用户态执行时的状态，而 TaskContext 保存的是用户程序进入内核执行的中间状态，TaskContext 在保存和恢复时不涉及到特权性的切换。</p>
</li>
<li><p>trapContext 是需要硬件辅助。TaskContext 不需要硬件的帮助，编译器为我们保存一部分 register。</p>
</li>
</ul>
<blockquote>
<p>trapContext 在哪里可以感知，硬件做了事情？</p>
</blockquote>
<ul>
<li>trapContext 恢复后就回到了用户态执行，TaskContext 恢复后继续执行 app 在内核的操作。</li>
</ul>
<h4 id="2-2-有了-trapContext，内核第一次如何进入用户态执行第一个-app？"><a href="#2-2-有了-trapContext，内核第一次如何进入用户态执行第一个-app？" class="headerlink" title="2.2 有了 trapContext，内核第一次如何进入用户态执行第一个 app？"></a>2.2 有了 trapContext，内核第一次如何进入用户态执行第一个 app？</h4><p><img src="/./pics/3_02.png"></p>
<p>run_first_task 完成从 kernel 到 U 的第一个 app，<code>TaskContext::zero_init()</code> 构造一个空的 <code>TaskContext</code>，<code>next_task_cx_ptr</code> 是 <code>第一个 app 的上下文</code> 作为 <code>__switch</code> 的第二个参数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Run the first task in task list.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// Generally, the first task in task list is an idle task (we call it zero process later).</span></span><br><span class="line"><span class="comment">/// But in ch3, we load apps statically, so the first task is a real app.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">run_first_task</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">inner</span> = <span class="keyword">self</span>.inner.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task0</span> = &amp;<span class="keyword">mut</span> inner.tasks[<span class="number">0</span>];</span><br><span class="line">    task0.task_status = TaskStatus::Running;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">next_task_cx_ptr</span> = &amp;task0.task_cx <span class="keyword">as</span> *<span class="keyword">const</span> TaskContext;</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(inner);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">_unused</span> = TaskContext::<span class="title function_ invoke__">zero_init</span>();</span><br><span class="line">    <span class="comment">// before this, we should drop local variables that must be dropped manually</span></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __switch(&amp;<span class="keyword">mut</span> _unused <span class="keyword">as</span> *<span class="keyword">mut</span> TaskContext, next_task_cx_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;unreachable in run_first_task!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">__switch:</span><br><span class="line">    # __switch(</span><br><span class="line">    #     current_task_cx_ptr: *mut TaskContext,</span><br><span class="line">    #     next_task_cx_ptr: *const TaskContext</span><br><span class="line">    # )</span><br><span class="line">    # save kernel stack of current task</span><br><span class="line">    sd sp, 8(a0)</span><br><span class="line">    # save ra &amp; s0~s11 of current execution</span><br><span class="line">    sd ra, 0(a0)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        SAVE_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore ra &amp; s0~s11 of next execution</span><br><span class="line">    ld ra, 0(a1)</span><br><span class="line">    .set n, 0</span><br><span class="line">    .rept 12</span><br><span class="line">        LOAD_SN %n</span><br><span class="line">        .set n, n + 1</span><br><span class="line">    .endr</span><br><span class="line">    # restore kernel stack of next task</span><br><span class="line">    ld sp, 8(a1)</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>

<p>先把当前任务的状态保存下来，然后把下一个任务的状态恢复，并且最后调一个 ret 返回到 ra 指向的地址处。</p>
<h4 id="2-3-上图左侧，构造好-trapContext，设好-ra-sp"><a href="#2-3-上图左侧，构造好-trapContext，设好-ra-sp" class="headerlink" title="2.3 上图左侧，构造好 trapContext，设好 ra &#x2F; sp"></a>2.3 上图左侧，构造好 trapContext，设好 ra &#x2F; sp</h4><p>内核在为这些用户程序构造任务上下文时，它做的事情。<br>TASK_MANAGER 在初始化时，为每个用户程序初始化了任务上下文，<br><code>init_app_cx(i)</code> 为每一个用户程序构造 trap 上下文，</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Global variable: TASK_MANAGER</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">static</span> <span class="keyword">ref</span> TASK_MANAGER: TaskManager = &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">num_app</span> = <span class="title function_ invoke__">get_num_app</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tasks</span> = [TaskControlBlock &#123;</span><br><span class="line">        task_cx: TaskContext::<span class="title function_ invoke__">zero_init</span>(),</span><br><span class="line">        task_status: TaskStatus::UnInit,</span><br><span class="line">    &#125;; MAX_APP_NUM];</span><br><span class="line">    <span class="keyword">for</span> (i, task) <span class="keyword">in</span> tasks.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        task.task_cx = TaskContext::<span class="title function_ invoke__">goto_restore</span>(<span class="title function_ invoke__">init_app_cx</span>(i));</span><br><span class="line">        task.task_status = TaskStatus::Ready;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为每一个用户程序在内核栈上构建 trapContext，每一个用户程序有了自己的内核栈。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// get app info with entry and sp and save `TrapContext` in kernel stack</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init_app_cx</span>(app_id: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    KERNEL_STACK[app_id].<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">        <span class="title function_ invoke__">get_base_i</span>(app_id),</span><br><span class="line">        USER_STACK[app_id].<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 trapContext 和批处理系统的逻辑是一样的，它的主要不同点是，现在，每一个用户程序都有了自己的内核栈了 <code>KERNEL_STACK[app_id]</code>。</p>
<p>因为批处理系统是一个接一个运行的，我们可以重复利用内核栈和用户栈。<br>但现在分时多任务系统不是一个接一个运行的，而是可以暂停一个，跳到去执行另一个。<br>所以，我们需要为每一个程序分配它的内核栈和用户栈。</p>
<blockquote>
<p>TODO: 这里的用户栈，好像从来没有讲到过，没有用过？</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Create a new task context with a trap return addr and a kernel stack pointer</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">goto_restore</span>(kstack_ptr: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">Self</span> &#123;</span><br><span class="line">        ra: __restore <span class="keyword">as</span> <span class="type">usize</span>,</span><br><span class="line">        sp: kstack_ptr,</span><br><span class="line">        s: [<span class="number">0</span>; <span class="number">12</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里把 rs 赋为 __restore 的地址，sp 赋了内核栈的地址，</p>
<h2 id="3-如果用户程序不交出控制权，内核通过时钟中断。"><a href="#3-如果用户程序不交出控制权，内核通过时钟中断。" class="headerlink" title="3 如果用户程序不交出控制权，内核通过时钟中断。"></a>3 如果用户程序不交出控制权，内核通过时钟中断。</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pub fn rust_main() -&gt; ! &#123;</span><br><span class="line">    ...</span><br><span class="line">    trap::enable_timer_interrupt();</span><br><span class="line">    timer::set_next_trigger();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="4-代码总览"><a href="#4-代码总览" class="headerlink" title="4 代码总览"></a>4 代码总览</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pub fn rust_main() -&gt; ! &#123;</span><br><span class="line">    clear_bss();</span><br><span class="line">    println!(&quot;[kernel] Hello, world!&quot;);</span><br><span class="line"></span><br><span class="line">    // 让 vec 指向 中断处理程序 alltrap。</span><br><span class="line">    trap::init();</span><br><span class="line"></span><br><span class="line">    // 把几个应用加载到相应的位置。</span><br><span class="line">    loader::load_apps();</span><br><span class="line"></span><br><span class="line">    // 设置时钟中断寄存器；</span><br><span class="line">    trap::enable_timer_interrupt();</span><br><span class="line"></span><br><span class="line">    // 设置时间间隔；</span><br><span class="line">    timer::set_next_trigger();</span><br><span class="line"></span><br><span class="line">    task::run_first_task();</span><br><span class="line"></span><br><span class="line">    panic!(&quot;Unreachable in rust_main!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-疑问"><a href="#5-疑问" class="headerlink" title="5 疑问"></a>5 疑问</h2><ol>
<li>app 是如何停下来的呢？</li>
</ol>
<p>mark_current_suspend()</p>
<ol start="2">
<li>看下面代码，第一种 helloworld 正常的系统调用 syscall 它没有调用 exit_current_and_run_next()，即一个简单的 helloworld 程序是如何切换为下一个程序的？</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// handle an interrupt, exception, or system call from user space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, bad addr = &#123;:#x&#125;, bad instruction = &#123;:#x&#125;, kernel killed it.&quot;</span>, stval, cx.sepc);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">exit_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Interrupt</span>(Interrupt::SupervisorTimer) =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">set_next_trigger</span>();</span><br><span class="line">            <span class="title function_ invoke__">suspend_current_and_run_next</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>分时系统如何用 gdb 调试？</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://goversion.github.io/2025/08/31/os2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhou tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/31/os2/" class="post-title-link" itemprop="url">os2</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-31 17:44:18 / 修改时间：17:45:17" itemprop="dateCreated datePublished" datetime="2025-08-31T17:44:18+08:00">2025-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OS-第二章：批处理系统"><a href="#OS-第二章：批处理系统" class="headerlink" title="OS 第二章：批处理系统"></a>OS 第二章：批处理系统</h1><p>批处理系统：</p>
<ul>
<li>trap 上下文的切换；<ul>
<li>特权级切换；</li>
<li>trap 上下文的保存和恢复；</li>
</ul>
</li>
<li>异常处理；<ul>
<li>系统调用；</li>
<li>其它异常；</li>
</ul>
</li>
</ul>
<blockquote>
<p>sscratch 像是在说，用户的内核栈在这里，现场要保存到这里。</p>
</blockquote>
<h2 id="0-总览"><a href="#0-总览" class="headerlink" title="0 总览"></a>0 总览</h2><p><img src="/./pics/2_03.jpg"></p>
<p><img src="/./pics/2_05.png"></p>
<p><img src="/./pics/2_08.png"></p>
<p>在内核态到用户态之间的切换，主要靠 syscall 和 ret 两条命令。</p>
<h2 id="1-从用户程序一侧的视角看"><a href="#1-从用户程序一侧的视角看" class="headerlink" title="1 从用户程序一侧的视角看"></a>1 从用户程序一侧的视角看</h2><p>作为批处理系统，从用户程序一侧的视角出发，先准备多个应用程序，加载一个到 0x80400000，运行它，再加载下一个到 0x80400000，如此循环。</p>
<ul>
<li>user&#x2F;src&#x2F;lib.rs 这里是 user 的主入口。</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="meta">#[link_section = <span class="string">&quot;.text.entry&quot;</span>]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>(argc: <span class="type">usize</span>, argv: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        HEAP.<span class="title function_ invoke__">lock</span>()</span><br><span class="line">            .<span class="title function_ invoke__">init</span>(HEAP_SPACE.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, USER_HEAP_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">v</span>: <span class="type">Vec</span>&lt;&amp;<span class="symbol">&#x27;static</span> <span class="type">str</span>&gt; = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..argc &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">str_start</span> = <span class="keyword">unsafe</span> &#123; ((argv + i * core::mem::size_of::&lt;<span class="type">usize</span>&gt;()) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">usize</span>).<span class="title function_ invoke__">read_volatile</span>() &#125;;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">len</span> = (<span class="number">0usize</span>..)</span><br><span class="line">            .<span class="title function_ invoke__">find</span>(|i| <span class="keyword">unsafe</span> &#123; ((str_start + *i) <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>).<span class="title function_ invoke__">read_volatile</span>() == <span class="number">0</span> &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        v.<span class="title function_ invoke__">push</span>(</span><br><span class="line">            core::<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(<span class="keyword">unsafe</span> &#123;</span><br><span class="line">                core::slice::<span class="title function_ invoke__">from_raw_parts</span>(str_start <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>, len)</span><br><span class="line">            &#125;)</span><br><span class="line">            .<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_ invoke__">exit</span>(<span class="title function_ invoke__">main</span>(argc, v.<span class="title function_ invoke__">as_slice</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[linkage = <span class="string">&quot;weak&quot;</span>]</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>(_argc: <span class="type">usize</span>, _argv: &amp;[&amp;<span class="type">str</span>]) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Cannot find main!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用完用户程序 <code>app</code> 后，为什么需要 <code>exit</code> 这个系统调用呢？</p>
<p>下面的代码，<code>linkage = &quot;weak&quot;</code>，下面也是一个 main，<br>当编译 app 时，如果 app main 不存在的话，就采用弱链接的实现，<br>这是为什么有两个 main 实现。</p>
<p>这里才是 user 的主入口程序。<br><code>exit(main(argc, v.as_slice()));</code><br>这一段代码，先调用 app；<br>app 结束之后，调用 exit 向 OS 发出请求；<br>下面的代码，<code>linkage = &quot;weak&quot;</code>，下面也是一个 main，<br>当编译 app 时，如果 app main 不存在的话，就采用弱链接的实现，<br>这是为什么有两个 main 实现。</p>
<h2 id="3-从-kernel-一侧的视角看"><a href="#3-从-kernel-一侧的视角看" class="headerlink" title="3 从 kernel 一侧的视角看"></a>3 从 kernel 一侧的视角看</h2><h3 id="3-1-将应用程序链接到内核"><a href="#3-1-将应用程序链接到内核" class="headerlink" title="3.1 将应用程序链接到内核"></a>3.1 将应用程序链接到内核</h3><p><code>build.rs</code> 生成 <code>link_app.S</code> 文件</p>
<ul>
<li>扫描 user 目录下的 app。</li>
<li>将编译出来的 binary 文件链接到内核里，和内核一起编译。</li>
</ul>
<p>  link_app.S 扫描 user 目录下的 <code>用户程序 app</code>。<br>然后 main.rs 中 引入 <code>global_asm!(include_str!(&quot;link_app.S&quot;));</code> 后，汇编的符号信息就可以使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    .align 3</span><br><span class="line">    .section .data</span><br><span class="line">    .global _num_app</span><br><span class="line">_num_app:</span><br><span class="line">    .quad 5</span><br><span class="line">    .quad app_0_start</span><br><span class="line">    .quad app_1_start</span><br><span class="line">    .quad app_2_start</span><br><span class="line">    .quad app_3_start</span><br><span class="line">    .quad app_4_start</span><br><span class="line">    .quad app_4_end</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_0_start</span><br><span class="line">    .global app_0_end</span><br><span class="line">app_0_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/00hello_world.bin&quot;</span><br><span class="line">app_0_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_1_start</span><br><span class="line">    .global app_1_end</span><br><span class="line">app_1_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/01store_fault.bin&quot;</span><br><span class="line">app_1_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_2_start</span><br><span class="line">    .global app_2_end</span><br><span class="line">app_2_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/02power.bin&quot;</span><br><span class="line">app_2_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_3_start</span><br><span class="line">    .global app_3_end</span><br><span class="line">app_3_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/03priv_inst.bin&quot;</span><br><span class="line">app_3_end:</span><br><span class="line"></span><br><span class="line">    .section .data</span><br><span class="line">    .global app_4_start</span><br><span class="line">    .global app_4_end</span><br><span class="line">app_4_start:</span><br><span class="line">    .incbin &quot;../user/target/riscv64gc-unknown-none-elf/release/04priv_csr.bin&quot;</span><br><span class="line">app_4_end:</span><br></pre></td></tr></table></figure>

<p>incbin 是汇编语言中的一个伪指令，用于将二进制文件的原始内容直接嵌入到当前的汇编文件中。</p>
<h3 id="3-2-batch-init"><a href="#3-2-batch-init" class="headerlink" title="3.2 batch::init()"></a>3.2 batch::init()</h3><ul>
<li>main.rs 文件主要有下面三行。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">trap::init();</span><br><span class="line">batch::init();</span><br><span class="line">batch::run_next_app();</span><br></pre></td></tr></table></figure>


<p><code>batch::init()</code> 找到 link_app.S 的符号信息，把值赋给 AppManager 这个结构体。</p>
<p><font color="red">这里没有看懂，batch::init() 是怎么调到下面的代码的？下面的 UPSafeCell 体是一个函数吗？</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">lazy_static! &#123;</span><br><span class="line">    static ref APP_MANAGER: UPSafeCell&lt;AppManager&gt; = unsafe &#123;</span><br><span class="line">        UPSafeCell::new(&#123;</span><br><span class="line">            extern &quot;C&quot; &#123;</span><br><span class="line">                fn _num_app();</span><br><span class="line">            &#125;</span><br><span class="line">            let num_app_ptr = _num_app as usize as *const usize;</span><br><span class="line">            let num_app = num_app_ptr.read_volatile();</span><br><span class="line">            let mut app_start: [usize; MAX_APP_NUM + 1] = [0; MAX_APP_NUM + 1];</span><br><span class="line">            let app_start_raw: &amp;[usize] =</span><br><span class="line">                core::slice::from_raw_parts(num_app_ptr.add(1), num_app + 1);</span><br><span class="line">            app_start[..=num_app].copy_from_slice(app_start_raw);</span><br><span class="line">            AppManager &#123;</span><br><span class="line">                num_app,</span><br><span class="line">                current_app: 0,</span><br><span class="line">                app_start,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-3-batch-run-next-app"><a href="#3-3-batch-run-next-app" class="headerlink" title="3.3  batch::run_next_app()"></a>3.3  batch::run_next_app()</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">run_next_app</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">app_manager</span> = APP_MANAGER.<span class="title function_ invoke__">exclusive_access</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">current_app</span> = app_manager.<span class="title function_ invoke__">get_current_app</span>();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        app_manager.<span class="title function_ invoke__">load_app</span>(current_app);</span><br><span class="line">    &#125;</span><br><span class="line">    app_manager.<span class="title function_ invoke__">move_to_next_app</span>();</span><br><span class="line">    <span class="title function_ invoke__">drop</span>(app_manager);</span><br><span class="line">    <span class="comment">// before this we have to drop local variables related to resources manually and release the resources</span></span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__restore</span>(cx_addr: <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        __restore(KERNEL_STACK.<span class="title function_ invoke__">push_context</span>(TrapContext::<span class="title function_ invoke__">app_init_context</span>(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.<span class="title function_ invoke__">get_sp</span>(),</span><br><span class="line">        )) <span class="keyword">as</span> *<span class="keyword">const</span> _ <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;Unreachable in batch::run_current_app!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>load_app</p>
<p>获取当前的 app，清然后通过 <code>load_app</code> 把 app 加载到内存里。<code>load_app</code> 具体干了什么事呢？</p>
<ul>
<li><code>if app_id &gt;= self.num_app</code>， 判断当前的 app 是否越界；</li>
<li>用 <code>from_raw_parts_mut.fill(0)</code> 把 <code>0x80400000 + 0x20000</code> 区域清 0；</li>
<li>用 <code>copy_from_slice</code> 把 app 的二进制文件 copy 到这块区域；</li>
<li><code>fence.i</code> 的意思是，避免执行前一个 app 的指令。即<code>清理 cpu 的指令缓存</code>中前一个 app 的指令；</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="keyword">fn</span> <span class="title function_">load_app</span>(&amp;<span class="keyword">self</span>, app_id: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> app_id &gt;= <span class="keyword">self</span>.num_app &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;All applications completed!&quot;</span>);</span><br><span class="line">        <span class="keyword">use</span> crate::board::QEMUExit;</span><br><span class="line">        crate::board::QEMU_EXIT_HANDLE.<span class="title function_ invoke__">exit_success</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;[kernel] Loading app_&#123;&#125;&quot;</span>, app_id);</span><br><span class="line">    <span class="comment">// clear app area</span></span><br><span class="line">    core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, APP_SIZE_LIMIT).<span class="title function_ invoke__">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_src</span> = core::slice::<span class="title function_ invoke__">from_raw_parts</span>(</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id] <span class="keyword">as</span> *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">        <span class="keyword">self</span>.app_start[app_id + <span class="number">1</span>] - <span class="keyword">self</span>.app_start[app_id],</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">app_dst</span> = core::slice::<span class="title function_ invoke__">from_raw_parts_mut</span>(APP_BASE_ADDRESS <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>, app_src.<span class="title function_ invoke__">len</span>());</span><br><span class="line">    app_dst.<span class="title function_ invoke__">copy_from_slice</span>(app_src);</span><br><span class="line"></span><br><span class="line">    asm!(<span class="string">&quot;fence.i&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color="red">这里有一个疑问，这里只看到了加载，哪里是执行用户程序的调用？</font></p>
<ul>
<li>__restore</li>
</ul>
<p><font color="#FF007F">要注意，保护现场保护的是什么？<strong>from A to B. 保护的是 A 的状态，即把用户程序跳转前的一瞬间的 cpu 的状态 <code>冰冻</code> 起来。</strong></font></p>
<p>先是构建一个 <code>TrapContext</code> 放入 <code>KERNEL_STACK</code> 内核栈里。然后把 <code>TrapContext</code> 地址作为 restore 的参数，restore 完成从内核态跳转到用户态去执行。</p>
<h3 id="3-4-对-TrapContext-的解释"><a href="#3-4-对-TrapContext-的解释" class="headerlink" title="3.4 对 TrapContext 的解释"></a>3.4 对 TrapContext 的解释</h3><p><img src="/./pics/2_01.png"></p>
<p><img src="/./pics/2_02.jpg"></p>
<p>从 A 到 B，从用户态到内核态。上表中，sstatus&#x2F;sepc&#x2F;scause&#x2F;stval 是 A 侧的信息，stvec 是 B 侧的信息。</p>
<p><font color="#FF007F">sepc 是 A 侧的地址，stvec 是 B 侧的地址。</font></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pub struct TrapContext &#123;</span><br><span class="line">    pub x: [usize; 32],</span><br><span class="line">    pub sstatus: Sstatus,</span><br><span class="line">    pub sepc: usize,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><font color="gray">我对 TrapContext 有点没有理解，为什么上图中 5 个寄存器，而 TrapContext 只保留了 2 个？</font></p>
<blockquote>
<p>老师说，发生嵌套时，可能覆盖现场。</p>
</blockquote>
<blockquote>
<p>贺兰星辰说，那 3 个寄存器不需要保存，因为那是由 cpu 给你分派过去的，用一次后面也不会再用。我们保存上面 2 个是因为后面要恢复。</p>
</blockquote>
</li>
<li><p>把 TrapContext 保持在哪里？</p>
<p>sstatus &#x2F; sepc 是高特权级的寄存器，放在用户栈不合适。保存在 <code>app 自己的</code> 内核栈。<br><font color="#FF007F">可以想像成，app 在用户态有一个临时储物箱，在同核态也有一个临时储物箱，而 TrapContext 放在内核态的临时储物箱。</font></p>
</li>
</ul>
<h3 id="3-5-trap-init"><a href="#3-5-trap-init" class="headerlink" title="3.5 trap::init()"></a>3.5 trap::init()</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">init</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">__alltraps</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        stvec::<span class="title function_ invoke__">write</span>(__alltraps <span class="keyword">as</span> <span class="type">usize</span>, TrapMode::Direct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>stvec::write</code> 写入了异常处理 <code>__alltraps</code> 的地址，即 <font color="#FF007F">stvec &#x3D; &amp;__alltraps</font>。<br>当用户程序 app 发出 syscall 时，跳转到 <code>__alltraps</code>，</p>
<p><code>csrrw sp, sscratch, sp</code> 交换用户栈和内核栈指针。交换后，现在的 sp 就指向了 app 内核栈。<br>将现场，即将寄存器和 2 个寄存器保存在内核栈上，<br>然后调用 trap_handler 去执行。</p>
<p>下面是异常处理的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__alltraps:</span><br><span class="line">    // 看 __restore 倒数第二行，就知道 内核栈指针保存在 sscratch 里。</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    # allocate a TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, -34*8</span><br><span class="line">    # save general-purpose registers</span><br><span class="line">    sd x1, 1*8(sp)</span><br><span class="line">    # skip sp(x2), we will save it later</span><br><span class="line">    sd x3, 3*8(sp)</span><br><span class="line">    # skip tp(x4), application does not use it</span><br><span class="line">    # save x5~x31</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        SAVE_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # we can use t0/t1/t2 freely, because they were saved on kernel stack</span><br><span class="line">    csrr t0, sstatus</span><br><span class="line">    csrr t1, sepc</span><br><span class="line">    sd t0, 32*8(sp)</span><br><span class="line">    sd t1, 33*8(sp)</span><br><span class="line">    # read user stack from sscratch and save it on the kernel stack</span><br><span class="line">    csrr t2, sscratch</span><br><span class="line">    sd t2, 2*8(sp)</span><br><span class="line">    # set input argument of trap_handler(cx: &amp;mut TrapContext)</span><br><span class="line">    mv a0, sp</span><br><span class="line">    call trap_handler</span><br></pre></td></tr></table></figure>

<p>trap_handler 是 OS 提供服务的地方。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// handle an interrupt, exception, or system call from user space</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">trap_handler</span>(cx: &amp;<span class="keyword">mut</span> TrapContext) <span class="punctuation">-&gt;</span> &amp;<span class="keyword">mut</span> TrapContext &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">scause</span> = scause::<span class="title function_ invoke__">read</span>(); <span class="comment">// get trap cause</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">stval</span> = stval::<span class="title function_ invoke__">read</span>(); <span class="comment">// get extra value</span></span><br><span class="line">    <span class="keyword">match</span> scause.<span class="title function_ invoke__">cause</span>() &#123;</span><br><span class="line">        <span class="comment">// syscall</span></span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::UserEnvCall) =&gt; &#123;</span><br><span class="line">            cx.sepc += <span class="number">4</span>;</span><br><span class="line">            cx.x[<span class="number">10</span>] = <span class="title function_ invoke__">syscall</span>(cx.x[<span class="number">17</span>], [cx.x[<span class="number">10</span>], cx.x[<span class="number">11</span>], cx.x[<span class="number">12</span>]]) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::StoreFault) | Trap::<span class="title function_ invoke__">Exception</span>(Exception::StorePageFault) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] PageFault in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        Trap::<span class="title function_ invoke__">Exception</span>(Exception::IllegalInstruction) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;[kernel] IllegalInstruction in application, kernel killed it.&quot;</span>);</span><br><span class="line">            <span class="title function_ invoke__">run_next_app</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="built_in">panic!</span>(</span><br><span class="line">                <span class="string">&quot;Unsupported trap &#123;:?&#125;, stval = &#123;:#x&#125;!&quot;</span>,</span><br><span class="line">                scause.<span class="title function_ invoke__">cause</span>(),</span><br><span class="line">                stval</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cx</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>从 scause 获取 syscall id。</li>
<li>syscall 后返回 cx.sepc +&#x3D; 4;</li>
</ul>
<blockquote>
<p><code>trap_handler</code> 结束之后，回到 __restore，这从哪里可以看得出来？<code>__restore</code> 做的事情与 <code>__alltraps</code> 相反。</p>
</blockquote>
<p>注意，上面第一个 Trap syscall 之后没有调用 run_next_app()，原因是 system_call 是在执行内核代码，并不切换 app，系统调用完了就返回原 task 继续运行了。gdb 一行代码一行代码跟着走，看看他是怎么执行的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__restore:</span><br><span class="line">    # case1: start running app by __restore</span><br><span class="line">    # case2: back to U after handling trap</span><br><span class="line"></span><br><span class="line">    // 注意 __restore(KERNEL_STACK(trapContext))，参数是 trapContext</span><br><span class="line">    mv sp, a0</span><br><span class="line"></span><br><span class="line">    # now sp-&gt;kernel stack(after allocated), sscratch-&gt;user stack</span><br><span class="line">    # restore sstatus/sepc</span><br><span class="line">    ld t0, 32*8(sp)</span><br><span class="line">    ld t1, 33*8(sp)</span><br><span class="line">    ld t2, 2*8(sp)</span><br><span class="line">    csrw sstatus, t0</span><br><span class="line">    csrw sepc, t1</span><br><span class="line">    csrw sscratch, t2</span><br><span class="line">    # restore general-purpuse registers except sp/tp</span><br><span class="line">    ld x1, 1*8(sp)</span><br><span class="line">    ld x3, 3*8(sp)</span><br><span class="line">    .set n, 5</span><br><span class="line">    .rept 27</span><br><span class="line">        LOAD_GP %n</span><br><span class="line">        .set n, n+1</span><br><span class="line">    .endr</span><br><span class="line">    # release TrapContext on kernel stack</span><br><span class="line">    addi sp, sp, 34*8</span><br><span class="line">    # now sp-&gt;kernel stack, sscratch-&gt;user stack</span><br><span class="line">    // 准备要退到用户态去执行了，把内核栈指针 sp 保存到 sscratch 里去，</span><br><span class="line">    csrrw sp, sscratch, sp</span><br><span class="line">    sret</span><br></pre></td></tr></table></figure>

<p>通过 sret 回到用户态。</p>
<p><code>__restore</code> 结尾的 <code>csrrw sp, sscratch, sp</code>，sp 原本指向内核栈指针，交换后，sp 指向用户栈，sscratch 指向内核栈。</p>
<p>再回过头来看 <code>__alltraps</code> 开头的 <code>csrrw sp, sscratch, sp</code>，从 sscratch 里获取内核栈。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">TrapContext</span> &#123;</span><br><span class="line">    <span class="comment">/// set stack pointer to x_2 reg (sp)</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">set_sp</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, sp: <span class="type">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.x[<span class="number">2</span>] = sp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// init app context</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">app_init_context</span>(entry: <span class="type">usize</span>, sp: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">sstatus</span> = sstatus::<span class="title function_ invoke__">read</span>(); <span class="comment">// CSR sstatus</span></span><br><span class="line">        sstatus.<span class="title function_ invoke__">set_spp</span>(SPP::User); <span class="comment">//previous privilege mode: user mode</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">cx</span> = <span class="keyword">Self</span> &#123;</span><br><span class="line">            x: [<span class="number">0</span>; <span class="number">32</span>],</span><br><span class="line">            sstatus,</span><br><span class="line">            sepc: entry, <span class="comment">// entry point of app</span></span><br><span class="line">        &#125;;</span><br><span class="line">        cx.<span class="title function_ invoke__">set_sp</span>(sp); <span class="comment">// app&#x27;s user stack pointer</span></span><br><span class="line">        cx <span class="comment">// return initial Trap Context of app</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>__alltraps</code> 和 <code>__restore</code> 里，直接存取那些 R，不需要 trapContext 呀。<br>那 trapContext 是为谁构建的一个结构？</p>
<h3 id="3-6-内核态第一次执行用户程序"><a href="#3-6-内核态第一次执行用户程序" class="headerlink" title="3.6 内核态第一次执行用户程序"></a>3.6 内核态第一次执行用户程序</h3><ul>
<li>batch::run_next_app()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pub fn run_next_app() -&gt; ! &#123;</span><br><span class="line">    ...</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        __restore(KERNEL_STACK.push_context(TrapContext::app_init_context(</span><br><span class="line">            APP_BASE_ADDRESS,</span><br><span class="line">            USER_STACK.get_sp(),</span><br><span class="line">        )) as *const _ as usize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/./pics/2_04.png"></p>
<h2 id="4-问题"><a href="#4-问题" class="headerlink" title="4 问题"></a>4 问题</h2><h4 id="1-UPSafeCell-背景，需要深入阅读-rust-相关资料。"><a href="#1-UPSafeCell-背景，需要深入阅读-rust-相关资料。" class="headerlink" title="1 UPSafeCell 背景，需要深入阅读 rust 相关资料。"></a>1 UPSafeCell 背景，需要深入阅读 rust 相关资料。</h4><h4 id="2-比如-hello-rc"><a href="#2-比如-hello-rc" class="headerlink" title="2 比如 hello.rc"></a>2 比如 hello.rc</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn main() -&gt; i32 &#123;</span><br><span class="line">    println!(&quot;Hello, world from user mode program!&quot;);</span><br><span class="line">    0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从 println 系统调用结束后，干了什么事？如何运行下一个 app <code>run_next_app()</code>？</p>
<h4 id="3-user-项目入口文件为什么需要名为-user-src-lib-rs，而不是-main-rs？"><a href="#3-user-项目入口文件为什么需要名为-user-src-lib-rs，而不是-main-rs？" class="headerlink" title="3 user 项目入口文件为什么需要名为 user&#x2F;src&#x2F;lib.rs，而不是 main.rs？"></a>3 user 项目入口文件为什么需要名为 user&#x2F;src&#x2F;lib.rs，而不是 main.rs？</h4><p>在 kernel 端，它可能没用处。<br>只是用于在 user 端作为调用。</p>
<h4 id="4-上述疑问，使-lab2-在细节的理解上，还存在点点没有串成线。并且在使用-gdb-上也存在问题，进入第一个-app-就退出了，原因不知，还有些莫名其妙。"><a href="#4-上述疑问，使-lab2-在细节的理解上，还存在点点没有串成线。并且在使用-gdb-上也存在问题，进入第一个-app-就退出了，原因不知，还有些莫名其妙。" class="headerlink" title="4 上述疑问，使 lab2 在细节的理解上，还存在点点没有串成线。并且在使用 gdb 上也存在问题，进入第一个 app 就退出了，原因不知，还有些莫名其妙。"></a>4 上述疑问，使 lab2 在细节的理解上，还存在点点没有串成线。并且在使用 gdb 上也存在问题，进入第一个 app 就退出了，原因不知，还有些莫名其妙。</h4><p>设置断点如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b os::batch::run_next_app</span><br></pre></td></tr></table></figure>

<p>通过 si 不能进入汇编语言 __restore，原因在哪里？</p>
<p>有空时，专门练习一下汇编语言GDB的调试办法。</p>
<h4 id="5-为什么-entry-asm-trap-s-都是汇编代码，但是不同的扩展名？"><a href="#5-为什么-entry-asm-trap-s-都是汇编代码，但是不同的扩展名？" class="headerlink" title="5 为什么 entry.asm &#x2F; trap.s 都是汇编代码，但是不同的扩展名？"></a>5 为什么 entry.asm &#x2F; trap.s 都是汇编代码，但是不同的扩展名？</h4><h4 id="6-查一下-csrrw-指令的意思？"><a href="#6-查一下-csrrw-指令的意思？" class="headerlink" title="6 查一下 csrrw 指令的意思？"></a>6 查一下 <code>csrrw</code> 指令的意思？</h4><p>csrrw: CSR read and write,</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/kuankuan02/article/details/95452616">https://blog.csdn.net/kuankuan02/article/details/95452616</a></p>
<h4 id="7-gdb-界面，为什么看不到-sscratch-寄存器？"><a href="#7-gdb-界面，为什么看不到-sscratch-寄存器？" class="headerlink" title="7 gdb 界面，为什么看不到 sscratch 寄存器？"></a>7 gdb 界面，为什么看不到 sscratch 寄存器？</h4><h4 id="8-load-app-后，是如何执行-app-的，其代码在哪里？"><a href="#8-load-app-后，是如何执行-app-的，其代码在哪里？" class="headerlink" title="8 load_app 后，是如何执行 app 的，其代码在哪里？"></a>8 load_app 后，是如何执行 app 的，其代码在哪里？</h4><p>执行用户代码 app，通过什么命令或其它方式？</p>
<h2 id="5-gdb-单步调试"><a href="#5-gdb-单步调试" class="headerlink" title="5 gdb 单步调试"></a>5 gdb 单步调试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译 user 代码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> user; make build</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">调试 os 代码</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> os  ; make debug</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找函数符号名称</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; info <span class="built_in">functions</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设 run_next_app 为断点</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; b os::batch::run_next_app</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; n 不进入</span></span><br></pre></td></tr></table></figure>

<p><img src="/./pics/2_07.png"></p>
<h2 id="6-细节补充：动手创建-user-工程。"><a href="#6-细节补充：动手创建-user-工程。" class="headerlink" title="6 细节补充：动手创建 user 工程。"></a>6 细节补充：动手创建 user 工程。</h2><ol>
<li>用 cargo 创建工程</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 在项目目录下创建 user 文件夹,用来储存 `用户态` 的代码。</span><br><span class="line">cargo new ./user</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>linker.ld<br><img src="/./pics/2_06.png"></p>
<ul>
<li>.rodata 已初始化的、全局的、只读数据。即只读常量。</li>
<li>.data  已初始化的、全局的、只读数据。即可修改常量。</li>
<li>.bss 未初始化的、全局数据，通常由程序的加载者代为进行零初始化。</li>
</ul>
</li>
<li><p>lib.rs &#x2F;&#x2F; 和 os 的 main.rs 一样。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#[no_mangle]</span><br><span class="line">#[link_section = &quot;.text.entry&quot;]</span><br><span class="line">pub extern &quot;C&quot; fn _start() -&gt; ! &#123;</span><br><span class="line">    clear_bss();</span><br><span class="line">    exit(main());</span><br><span class="line">    panic!(&quot;unreachable after sys_exit!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>syscall.rs</li>
</ol>
<p>那么就可以在syscall.rs文件下创建接口:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// user/src/syscall.rs</span><br><span class="line">use core::arch::asm;</span><br><span class="line">fn syscall(id: usize, args: [usize; 3]) -&gt; isize &#123;</span><br><span class="line">    let mut ret: isize;</span><br><span class="line">    unsafe &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            &quot;ecall&quot;,</span><br><span class="line">            inlateout(&quot;x10&quot;) args[0] =&gt; ret,</span><br><span class="line">            in(&quot;x11&quot;) args[1],</span><br><span class="line">            in(&quot;x12&quot;) args[2],</span><br><span class="line">            in(&quot;x17&quot;) id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>console.rs</li>
<li>测试</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make build          //生成二进制</span><br><span class="line">qemu-riscv64 ./00hello_world</span><br><span class="line">qemu-riscv64 ./01store_fault</span><br><span class="line">qemu-riscv64 ./02power</span><br></pre></td></tr></table></figure>



<hr>
<p>在本章中，应用程序和批处理系统之间按照 API 的结构，约定如下两个系统调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/// 功能：将内存中缓冲区中的数据写入文件。</span><br><span class="line">/// 参数：`fd` 表示待写入文件的文件描述符；</span><br><span class="line">///      `buf` 表示内存中缓冲区的起始地址；</span><br><span class="line">///      `len` 表示内存中缓冲区的长度。</span><br><span class="line">/// 返回值：返回成功写入的长度。</span><br><span class="line">/// syscall ID：64</span><br><span class="line">fn sys_write(fd: usize, buf: *const u8, len: usize) -&gt; isize;</span><br><span class="line"></span><br><span class="line">/// 功能：退出应用程序并将返回值告知批处理系统。</span><br><span class="line">/// 参数：`exit_code` 表示应用程序的返回值。</span><br><span class="line">/// 返回值：该系统调用不应该返回。</span><br><span class="line">/// syscall ID：93</span><br><span class="line">fn sys_exit(exit_code: usize) -&gt; !;</span><br></pre></td></tr></table></figure>
<p>那么对应的,我们可以使用syscall来实现这两个API:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// user/src/syscall.rs</span><br><span class="line"></span><br><span class="line">const SYSCALL_WRITE: usize = 64;</span><br><span class="line">const SYSCALL_EXIT: usize = 93;</span><br><span class="line"></span><br><span class="line">pub fn sys_write(fd: usize, buffer: &amp;[u8]) -&gt; isize &#123;</span><br><span class="line">    syscall(SYSCALL_WRITE, [fd, buffer.as_ptr() as usize, buffer.len()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn sys_exit(xstate: i32) -&gt; isize &#123;</span><br><span class="line">    syscall(SYSCALL_EXIT, [xstate as usize, 0, 0])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意 sys_write 使用一个 &amp;[u8] 切片类型来描述缓冲区，这是一个 胖指针 (Fat Pointer)，里面既包含缓冲区的起始地址，还 包含缓冲区的长度。我们可以分别通过 as_ptr 和 len 方法取出它们并独立地作为实际的系统调用参数。</p>
<h4 id="进一步封装接口"><a href="#进一步封装接口" class="headerlink" title="进一步封装接口"></a>进一步封装接口</h4><p>为了将上述两个系统调用在用户库 user_lib 中进一步封装，从而更加接近在 Linux 等平台的实际系统调用接口,修改lib.rs文件,在其中键入:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mod syscall;</span><br><span class="line"></span><br><span class="line">use syscall::*;</span><br><span class="line"></span><br><span class="line">pub fn write(fd: usize, buf: &amp;[u8]) -&gt; isize &#123;</span><br><span class="line">    sys_write(fd, buf)</span><br><span class="line">&#125;</span><br><span class="line">pub fn exit(exit_code: i32) -&gt; isize &#123;</span><br><span class="line">    sys_exit(exit_code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更改console的实现"><a href="#更改console的实现" class="headerlink" title="更改console的实现"></a>更改console的实现</h4><p>我们把 console 子模块中 Stdout::write_str 改成基于 write 的实现，且传入的 fd 参数设置为 1，它代表标准输出， 也就是输出到屏幕。目前我们不需要考虑其他的 fd 选取情况。这样，应用程序的 println! 宏借助系统调用变得可用了。</p>
<p>创建console.rs文件,内容和第一章该模块保持一致,只修改Stdout的Write特性的实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// user/src/console.rs</span><br><span class="line">const STDOUT: usize = 1;</span><br><span class="line"></span><br><span class="line">impl Write for Stdout &#123;</span><br><span class="line">    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;</span><br><span class="line">        write(STDOUT, s.as_bytes());</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终的文件内容为:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">use super::write;</span><br><span class="line">use core::fmt::&#123;self, Write&#125;;</span><br><span class="line"></span><br><span class="line">struct Stdout;</span><br><span class="line"></span><br><span class="line">const STDOUT: usize = 1;</span><br><span class="line"></span><br><span class="line">impl Write for Stdout &#123;</span><br><span class="line">    fn write_str(&amp;mut self, s: &amp;str) -&gt; fmt::Result &#123;</span><br><span class="line">        write(STDOUT, s.as_bytes());</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pub fn print(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.write_fmt(args).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::print(format_args!($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#[macro_export]</span><br><span class="line">macro_rules! println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::print(format_args!(concat!($fmt, &quot;\n&quot;) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-作业"><a href="#7-作业" class="headerlink" title="7 作业"></a>7 作业</h2><h2 id="8-TODO"><a href="#8-TODO" class="headerlink" title="8 TODO"></a>8 TODO</h2><ul>
<li><p>完成作业。</p>
</li>
<li><p>把所有疑问搞清楚。</p>
</li>
</ul>
<h2 id="9-参考："><a href="#9-参考：" class="headerlink" title="9 参考："></a>9 参考：</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenhan-winddevil/p/18312966">https://www.cnblogs.com/chenhan-winddevil/p/18312966</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://goversion.github.io/2025/08/31/os1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhou tao">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Hexo">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/31/os1/" class="post-title-link" itemprop="url">os1</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-31 17:39:28 / 修改时间：17:41:22" itemprop="dateCreated datePublished" datetime="2025-08-31T17:39:28+08:00">2025-08-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="OS-第一章：基本执行环境"><a href="#OS-第一章：基本执行环境" class="headerlink" title="OS 第一章：基本执行环境"></a>OS 第一章：基本执行环境</h1><h2 id="0-预备知识"><a href="#0-预备知识" class="headerlink" title="0 预备知识"></a>0 预备知识</h2><ul>
<li><p>sbi 位于 M 态，为操作系统提供服务。</p>
</li>
<li><p>程序编译的过程：</p>
<ol>
<li>对源代码展开，把宏展开成源代码。</li>
<li>把高级语言转换成汇编程序。</li>
<li>汇编程序转换成机器语言。</li>
<li>把机器语言汇总在一起，转换为一个成执行的文件。</li>
</ol>
</li>
<li><p>修改编译目标 + 剥掉标准库</p>
<p>从一个普通的 app，到一个 bare app，我们需要做的是：</p>
<ul>
<li>重新指定 <code>三元组</code>，即修改编译目标；</li>
<li>剥掉 <code>标准库</code>；</li>
<li>剥掉 <code>os kernel</code>；</li>
<li>app 直接操作硬件平台；</li>
</ul>
</li>
</ul>
<h2 id="1-准备环境"><a href="#1-准备环境" class="headerlink" title="1 准备环境"></a>1 准备环境</h2><h4 id="1-1-安装-rust"><a href="#1-1-安装-rust" class="headerlink" title="1.1 安装 rust"></a>1.1 安装 rust</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br><span class="line">export RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br><span class="line"></span><br><span class="line">选 2. Customize installation，选 nightly 配置，</span><br><span class="line"></span><br><span class="line">再选 1. Proceed with installation (default) 按上面的配置安装。</span><br></pre></td></tr></table></figure>


<p>更换为国内源</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -vp $&#123;CARGO_HOME:-$HOME/.cargo&#125;</span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF | tee -a $&#123;CARGO_HOME:-$HOME/.cargo&#125;/config</span><br><span class="line">[source.crates-io]</span><br><span class="line">replace-with = &#x27;mirror&#x27;</span><br><span class="line"></span><br><span class="line">[source.mirror]</span><br><span class="line">registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rustup install nightly</span><br><span class="line">rustup default nightly</span><br><span class="line"></span><br><span class="line">rustup target add riscv64gc-unknown-none-elf</span><br><span class="line">cargo install cargo-binutils</span><br><span class="line">rustup component add llvm-tools-preview</span><br><span class="line">rustup component add rust-src</span><br></pre></td></tr></table></figure>

<p>Visual Studio Code 搭配 rust-analyzer 和 RISC-V Support 插件。</p>
<h4 id="1-2-安装-qemu"><a href="#1-2-安装-qemu" class="headerlink" title="1.2 安装 qemu"></a>1.2 安装 qemu</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \</span><br><span class="line">              gawk build-essential bison flex texinfo gperf libtool patchutils bc \</span><br><span class="line">              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev libslirp-dev \</span><br><span class="line">              git tmux python3 python3-pip ninja-build</span><br><span class="line"></span><br><span class="line">wget https://download.qemu.org/qemu-7.0.0.tar.xz</span><br><span class="line"></span><br><span class="line">tar xvJf qemu-7.0.0.tar.xz</span><br><span class="line"></span><br><span class="line">cd qemu-7.0.0</span><br><span class="line"></span><br><span class="line">./configure --target-list=riscv64-softmmu,riscv64-linux-user</span><br><span class="line"></span><br><span class="line">// 可以有图形界面和网络。如果要支持图形界面，可添加 &quot; --enable-sdl&quot; 参数；如果要支持网络，可添加 &quot; --enable-slirp&quot; 参数</span><br><span class="line"></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/home/xu/workspace/31.os/qemu-7.0.0/build</span><br><span class="line"></span><br><span class="line">qemu-system-riscv64 --version</span><br><span class="line"></span><br><span class="line">qemu-riscv64 --version</span><br></pre></td></tr></table></figure>



<h2 id="2-构建用户态执行环境。利用-qemu-riscv64-提供-OS-kernel能力，实现一个简单的用户态程序。"><a href="#2-构建用户态执行环境。利用-qemu-riscv64-提供-OS-kernel能力，实现一个简单的用户态程序。" class="headerlink" title="2 构建用户态执行环境。利用 qemu-riscv64 提供 OS kernel能力，实现一个简单的用户态程序。"></a>2 构建用户态执行环境。利用 <code>qemu-riscv64</code> 提供 <code>OS kernel</code>能力，实现一个简单的用户态程序。</h2><p><img src="/./pics/1_01.png"></p>
<p>上图 1 从 hello world 出发，具体细节：</p>
<h4 id="2-1-缺-std"><a href="#2-1-缺-std" class="headerlink" title="2.1 缺 std"></a>2.1 缺 std</h4><p>通过加 no_std；</p>
<h4 id="2-2-缺-println"><a href="#2-2-缺-println" class="headerlink" title="2.2 缺 println"></a>2.2 缺 println</h4><p>暂时注释掉；</p>
<h4 id="2-3-缺-panic-（rust-程序里出了错，如非法访问造成程序崩溃，就需要panic，处理崩溃的实现-）"><a href="#2-3-缺-panic-（rust-程序里出了错，如非法访问造成程序崩溃，就需要panic，处理崩溃的实现-）" class="headerlink" title="2.3 缺 panic （rust 程序里出了错，如非法访问造成程序崩溃，就需要panic，处理崩溃的实现 ）"></a>2.3 缺 panic （rust 程序里出了错，如非法访问造成程序崩溃，就需要panic，处理崩溃的实现 ）</h4><h4 id="2-4-不支持-main-，因为没有-std-的原因"><a href="#2-4-不支持-main-，因为没有-std-的原因" class="headerlink" title="2.4 不支持 main ，因为没有 std 的原因"></a>2.4 不支持 main ，因为没有 std 的原因</h4><p>通过加 no_main，告诉编译器，不要去找 main &#x2F; start，此时这个程序的代码段什么都没有。</p>
<h4 id="2-5-加上-start-语言项"><a href="#2-5-加上-start-语言项" class="headerlink" title="2.5 加上 start 语言项"></a>2.5 加上 start 语言项</h4><p>现在的代码如下：</p>
<ul>
<li>lang_items.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>main.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(asm)]</span></span><br><span class="line"><span class="meta">#![feature(panic_info_message)]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/lang_items.rs</span></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">cargo build</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qemu-riscv64 target/riscv64gc-unknown-none-elf/debug/os</span></span><br><span class="line"> segmentation fault (core dumped)</span><br></pre></td></tr></table></figure>

<p>上面的代码编译执行会报 ‘segmentation fault’，因为目前的执行环境还缺了一个退出机制，我们需要调用 kernel 提供的 exit 系统调用来退出程序。</p>
<h4 id="2-6-发出一个系统调用-exit"><a href="#2-6-发出一个系统调用-exit" class="headerlink" title="2.6 发出一个系统调用 exit"></a>2.6 发出一个系统调用 exit</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        core::arch::asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br><span class="line"></span><br><span class="line">qemu-riscv64 target/riscv64gc-unknown-none-elf/debug/os; echo $?</span><br></pre></td></tr></table></figure>

<h4 id="2-7-添加-print-功能"><a href="#2-7-添加-print-功能" class="headerlink" title="2.7 添加 print 功能"></a>2.7 添加 print 功能</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">  <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">然后实现基于 Write Trait 的数据结构，并完成 Write Trait 所需要的 write_str 函数，并用 print 函数进行包装。</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sys_write</span>(<span class="number">1</span>, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">最后，实现基于 print 函数，实现Rust语言 格式化宏 ( formatting macros )。</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">接下来，我们调整一下应用程序，让它发出显示字符串和退出的请求：</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终，用户程序可以向 qemu-riscv64 提供的 kernel 发出 print &#x2F; exit 的系统调用。</p>
<h2 id="3-构建裸机执行环境。利用-qemu-system-riscv64-把-OS-kernel-去掉"><a href="#3-构建裸机执行环境。利用-qemu-system-riscv64-把-OS-kernel-去掉" class="headerlink" title="3 构建裸机执行环境。利用 qemu-system-riscv64 把 OS kernel 去掉"></a>3 构建裸机执行环境。利用 <code>qemu-system-riscv64</code> 把 <code>OS kernel</code> 去掉</h2><p>把 Hello world! 应用程序从用户态搬到内核态。</p>
<h4 id="qemu-system-riscv64"><a href="#qemu-system-riscv64" class="headerlink" title="qemu-system-riscv64"></a>qemu-system-riscv64</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">            -machine virt \</span><br><span class="line">            -nographic \</span><br><span class="line">            -bios $(BOOTLOADER) \</span><br><span class="line">            -device loader,file=$(KERNEL_BIN),addr=$(KERNEL_ENTRY_PA)</span><br></pre></td></tr></table></figure>
<p>CPU 的其它通用寄存器清零，而 PC 会指向 0x1000 的位置，这里有固化在硬件中的一小段引导代码，它会很快跳转到 0x80000000 的 RustSBI 处。 RustSBI 完成硬件初始化后，会跳转到 $(KERNEL_BIN) 所在内存位置 0x80200000 处， 执行操作系统的第一条指令。</p>
<p>后面 gdb 调试的小节里，可以看到 0x1000 的位置只有 6 行代码。</p>
<h4 id="3-1-对上一节实现的代码稍作调整，把-exit-替换为-shutdown。通过-ecall-调用-RustSBI-实现关机功能。"><a href="#3-1-对上一节实现的代码稍作调整，把-exit-替换为-shutdown。通过-ecall-调用-RustSBI-实现关机功能。" class="headerlink" title="3.1 对上一节实现的代码稍作调整，把 exit 替换为 shutdown。通过 ecall 调用 RustSBI 实现关机功能。"></a>3.1 对上一节实现的代码稍作调整，把 exit 替换为 shutdown。通过 ecall 调用 RustSBI 实现关机功能。</h4><p>前者是 exit 是一个 syscall 调用 kernel 的服务，后者 shutdown 是 kernel 调用 sbi 的服务。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>替换成：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os/src/sbi.rs</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SBI_SHUTDOWN: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// os/src/main.rs</span></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 qemu-system-riscv64 测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cargo build --release</span><br><span class="line"></span><br><span class="line">rust-objcopy --binary-architecture=riscv64 target/riscv64gc-unknown-none-elf/release/os --strip-all -O binary target/riscv64gc-unknown-none-elf/release/os.bin</span><br><span class="line"></span><br><span class="line">qemu-system-riscv64 -machine virt -nographic -bios ../bootloader/rustsbi-qemu.bin -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000</span><br><span class="line"></span><br><span class="line">rust-readobj -h target/riscv64gc-unknown-none-elf/release/os</span><br></pre></td></tr></table></figure>

<p>注意 <code>-bios $(BOOTLOADER)</code> 意味着硬件加载了一个 BootLoader 程序，即 <code>SBI</code>。</p>
<p><img src="/./pics/1_03.png"></p>
<p>上面进程无法退出，风扇狂转，感觉碰到死循环，卡死了。</p>
<p>问题在哪？通过 rust-readobj 分析 os 可执行程序，发现其入口地址不是 RustSBI 约定的 0x80200000 。</p>
<p>也就是说，通过 <code>qemu-system-riscv64 addr=0x80200000</code> 没有起作用。</p>
<p>我们需要修改程序的内存布局并设置好栈空间。</p>
<h4 id="3-2-添加链接脚本-linker-ld"><a href="#3-2-添加链接脚本-linker-ld" class="headerlink" title="3.2 添加链接脚本 linker.ld"></a>3.2 添加链接脚本 linker.ld</h4><p>上面的 1.6 编译之后，起始地址是一个随机的默认的地址，但我们希望它的起始地址是 0x80200000，因此我们需要一个 linker 告诉编译器，如何放置 text,code.codata,等。</p>
<p>.cargo&#x2F;config.toml 放置了 linker.ld 文件。</p>
<h4 id="3-3-配置栈"><a href="#3-3-配置栈" class="headerlink" title="3.3 配置栈"></a>3.3 配置栈</h4><p>写 app 时，我们不需要准备栈，qemu-riscv64 会为我们准备这个栈。<br>现在在祼机上运行了，我们需要自己准备栈。</p>
<p>如果自己不准备栈，sp 会仍然指向 qemu-system-riscv64 启动时执行到 SBI 时的栈，kernel 就会把 SBI 的栈损坏。</p>
<p>所以，在 _start 一开始，我们要先准备栈，再进入 rust_main。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    la sp, boot_stack_top</span><br><span class="line">    call rust_main</span><br><span class="line"></span><br><span class="line">    .section .bss.stack</span><br><span class="line">    .globl boot_stack_lower_bound</span><br><span class="line">boot_stack_lower_bound:</span><br><span class="line">    .space 4096 * 16</span><br><span class="line">    .globl boot_stack_top</span><br><span class="line">boot_stack_top:</span><br></pre></td></tr></table></figure>

<h4 id="3-4-使用-SBI-服务，打印一个字符"><a href="#3-4-使用-SBI-服务，打印一个字符" class="headerlink" title="3.4 使用 SBI 服务，打印一个字符"></a>3.4 使用 SBI 服务，打印一个字符</h4><p><img src="/./pics/1_04.png"></p>
<p>上图的 syscall 参数规范，</p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://d3s.mff.cuni.cz/files/teaching/nswi200/202324/doc/riscv-abi.pdf">https://d3s.mff.cuni.cz/files/teaching/nswi200/202324/doc/riscv-abi.pdf</a></li>
<li>参考：<a target="_blank" rel="noopener" href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">https://jborza.com/post/2021-05-11-riscv-linux-syscalls/</a></li>
</ul>
<p>上图的 SBI 参数规范，</p>
<ul>
<li>参考：<a target="_blank" rel="noopener" href="https://www.scs.stanford.edu/~zyedidia/docs/riscv/riscv-sbi.pdf">https://www.scs.stanford.edu/~zyedidia/docs/riscv/riscv-sbi.pdf</a></li>
</ul>
<h4 id="3-5-打印一个字符串"><a href="#3-5-打印一个字符串" class="headerlink" title="3.5 打印一个字符串"></a>3.5 打印一个字符串</h4><p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://rustwiki.org/zh-CN/std/fmt/trait.Write.html">https://rustwiki.org/zh-CN/std/fmt/trait.Write.html</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/s/rust%20no_std%20fmt">https://juejin.cn/s/rust%20no_std%20fmt</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangxianghehe/article/details/92839138">https://blog.csdn.net/xiangxianghehe/article/details/92839138</a></li>
<li><a target="_blank" rel="noopener" href="https://xy-plus.gitbook.io/rcore-step-by-step/ge-shi-hua-shu-chu">https://xy-plus.gitbook.io/rcore-step-by-step/ge-shi-hua-shu-chu</a></li>
</ul>
<p>总结以上的流程：</p>
<p>去掉 std，添加 panic，去掉 no_main，添加 syscall 调用，这样具备了一个应用程序的基本功能了。</p>
<p>然后，写 syscall 实现部分，准备 kernel 栈，指定链接脚本，因为现在的 syscall 在往下调用 sbi，最后把这个 sbi 也去掉，真正去调用硬件。</p>
<h2 id="4-安装-gdb-与使用"><a href="#4-安装-gdb-与使用" class="headerlink" title="4 安装 gdb 与使用"></a>4 安装 gdb 与使用</h2><h4 id="4-1-安装-gdb"><a href="#4-1-安装-gdb" class="headerlink" title="4.1 安装 gdb"></a>4.1 安装 gdb</h4><ul>
<li><p>下载 gdb 最新版 ：<br><a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/">https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/</a></p>
</li>
<li><p>编译</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">cd gdb-XXX</span><br><span class="line">mkdir build-riscv64</span><br><span class="line">cd build-riscv64</span><br><span class="line">sudo apt-get install libncurses5-dev texinfo libreadline-dev</span><br><span class="line">../configure --prefix=/home/xu/workspace/31.os/gdb-15.1/build-riscv64 --with-python=/usr/bin/python --target=riscv64-unknown-elf --enable-tui=yes</span><br><span class="line"></span><br><span class="line">make -j$(nproc)</span><br><span class="line"></span><br><span class="line">make install</span><br><span class="line">./bin/riscv64-unknown-elf-gdb --version</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/home/xu/workspace/31.os/qemu-7.0.0/build:/home/xu/workspace/31.os/gdb-15.2/build-riscv64/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 gdb-dashboard 插件：<a target="_blank" rel="noopener" href="https://github.com/cyrus-and/gdb-dashboard">https://github.com/cyrus-and/gdb-dashboard</a></li>
</ul>
<h4 id="4-2-gdb-操作说明"><a href="#4-2-gdb-操作说明" class="headerlink" title="4.2 gdb 操作说明"></a>4.2 gdb 操作说明</h4><h6 id="GDB-命令"><a href="#GDB-命令" class="headerlink" title="GDB 命令"></a>GDB 命令</h6><p>make debug MODE&#x3D;debug LOG&#x3D;INFO</p>
<ul>
<li>tui layout src</li>
<li>b <funcName>: 添加断点</li>
<li>c: 继续运行, 遇到断点会中断</li>
<li>s: 执行下一行代码，进入函数</li>
<li>n: 执行下一行代码, 不进入函数</li>
<li>info reg</li>
<li>finish：结束当前函数，返回到函数调用点</li>
<li>ni&#x2F;si：是执行一条汇编指令，不是执行一条rust语句</li>
</ul>
<h6 id="设断点"><a href="#设断点" class="headerlink" title="设断点"></a>设断点</h6><p>通过 <code>info functions</code> 找到main 符号。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info function run_next_app</span><br><span class="line">(gdb) b os::batch::run_next_app</span><br></pre></td></tr></table></figure>

<h6 id="接下来要做的事"><a href="#接下来要做的事" class="headerlink" title="接下来要做的事"></a>接下来要做的事</h6><p>见上图，通过 si 不能进入汇编语言 __restore，原因在哪里？</p>
<p>有空时，专门练习一下汇编语言GDB的调试办法。</p>
<h6 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h6><ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bonelee/p/13759115.html">https://www.cnblogs.com/bonelee/p/13759115.html</a></li>
</ul>
<h4 id="4-3-单步调试"><a href="#4-3-单步调试" class="headerlink" title="4.3 单步调试"></a>4.3 单步调试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-riscv64 \</span><br><span class="line">    -machine virt \</span><br><span class="line">    -nographic \</span><br><span class="line">    -bios ../bootloader/rustsbi-qemu.bin \</span><br><span class="line">    -device loader,file=target/riscv64gc-unknown-none-elf/release/os.bin,addr=0x80200000 \</span><br><span class="line">    -s -S</span><br></pre></td></tr></table></figure>
<p>在 ubuntu 的开发环境，需要把 bootloader&#x2F;rustsbi-qemu.bin 文件替换掉，最新版下载地址为：<a target="_blank" rel="noopener" href="https://github.com/rustsbi/rustsbi-qemu/releases%E3%80%82">https://github.com/rustsbi/rustsbi-qemu/releases。</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">riscv64-unknown-elf-gdb \</span><br><span class="line">    -ex &#x27;file target/riscv64gc-unknown-none-elf/release/os&#x27; \</span><br><span class="line">    -ex &#x27;set arch riscv:rv64&#x27; \</span><br><span class="line">    -ex &#x27;target remote localhost:1234&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Qemu 启动后 PC 被初始化为 0x1000</span></span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000000001004 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000000001008 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x000000000000100c in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000000001010 in ?? ()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">p: <span class="built_in">print</span></span></span><br><span class="line"></span><br><span class="line">(gdb) p/x $t0</span><br><span class="line">1 = 0x80000000</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000080000000 in ?? ()</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用examine命令(简写是x)来查看内存地址中的值，x Examine memory: x/FMT ADDRESS. ADDRESS is an expression <span class="keyword">for</span> the memory address to examine.</span></span><br><span class="line"></span><br><span class="line">(gdb) x/10i $pc</span><br><span class="line">=&gt; 0x80000000:      auipc   sp,0x28</span><br><span class="line">0x80000004: mv      sp,sp</span><br><span class="line">0x80000008: lui     t0,0x4</span><br><span class="line">0x8000000a: addi    t1,a0,1</span><br><span class="line">0x8000000e: add     sp,sp,t0</span><br><span class="line">0x80000010: addi    t1,t1,-1</span><br><span class="line">0x80000012: bnez    t1,0x8000000e</span><br><span class="line">0x80000016: j       0x8001125a</span><br><span class="line">0x8000001a: unimp</span><br><span class="line">0x8000001c: addi    sp,sp,-48</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000080000004 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000000080000008 in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x000000008000000a in ?? ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x000000008000000e in ?? ()</span><br><span class="line">(gdb) b *0x80200000</span><br><span class="line">Breakpoint 1 at 0x80200000</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x0000000080200000 in ?? ()</span><br></pre></td></tr></table></figure>


<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zjp-cn.github.io/os-notes/rcore-gdb.html">https://zjp-cn.github.io/os-notes/rcore-gdb.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenhan-winddevil/p/18292657">https://www.cnblogs.com/chenhan-winddevil/p/18292657</a></li>
</ul>
<h2 id="5-构建用户态执行环境代码"><a href="#5-构建用户态执行环境代码" class="headerlink" title="5 构建用户态执行环境代码"></a>5 构建用户态执行环境代码</h2><p>共有以下两个代码文件：</p>
<ul>
<li>main.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(asm)]</span></span><br><span class="line"><span class="meta">#![feature(panic_info_message)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">sys_write</span>(<span class="number">1</span>, s.<span class="title function_ invoke__">as_bytes</span>());</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        <span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SYSCALL_EXIT: <span class="type">usize</span> = <span class="number">93</span>;</span><br><span class="line"><span class="keyword">const</span> SYSCALL_WRITE: <span class="type">usize</span> = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">syscall</span>(id: <span class="type">usize</span>, args: [<span class="type">usize</span>; <span class="number">3</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) args[<span class="number">0</span>] =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) args[<span class="number">1</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) args[<span class="number">2</span>],</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) id,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_exit</span>(xstate: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_EXIT, [xstate <span class="keyword">as</span> <span class="type">usize</span>, <span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">sys_write</span>(fd: <span class="type">usize</span>, buffer: &amp;[<span class="type">u8</span>]) <span class="punctuation">-&gt;</span> <span class="type">isize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">syscall</span>(SYSCALL_WRITE, [fd, buffer.<span class="title function_ invoke__">as_ptr</span>() <span class="keyword">as</span> <span class="type">usize</span>, buffer.<span class="title function_ invoke__">len</span>()])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">fn</span> <span class="title function_">_start</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">sys_exit</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>lang_items.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-构建裸机执行环境代码"><a href="#6-构建裸机执行环境代码" class="headerlink" title="6 构建裸机执行环境代码"></a>6 构建裸机执行环境代码</h2><ul>
<li>main.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![no_std]</span></span><br><span class="line"><span class="meta">#![no_main]</span></span><br><span class="line"><span class="meta">#![feature(asm)]</span></span><br><span class="line"><span class="meta">#![feature(panic_info_message)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> console;</span><br><span class="line"><span class="keyword">mod</span> lang_items;</span><br><span class="line"><span class="keyword">mod</span> sbi;</span><br><span class="line">core::arch::global_asm!(<span class="built_in">include_str!</span>(<span class="string">&quot;entry.asm&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> sbi_rt::legacy::shutdown;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">clear_bss</span>() &#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">sbss</span>();</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">ebss</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    (sbss <span class="keyword">as</span> <span class="type">usize</span>..ebss <span class="keyword">as</span> <span class="type">usize</span>).for_each(|a| &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123; (a <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="type">u8</span>).<span class="title function_ invoke__">write_volatile</span>(<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">rust_main</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">clear_bss</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    <span class="comment">// sys_exit(9);</span></span><br><span class="line">    <span class="title function_ invoke__">shutdown</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>sbi.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#![allow(unused)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::arch::asm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SBI_SET_TIMER: <span class="type">usize</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_CONSOLE_PUTCHAR: <span class="type">usize</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_CONSOLE_GETCHAR: <span class="type">usize</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_CLEAR_IPI: <span class="type">usize</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_SEND_IPI: <span class="type">usize</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_REMOTE_FENCE_I: <span class="type">usize</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_REMOTE_SFENCE_VMA: <span class="type">usize</span> = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_REMOTE_SFENCE_VMA_ASID: <span class="type">usize</span> = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> SBI_SHUTDOWN: <span class="type">usize</span> = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[inline(always)]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sbi_call</span>(which: <span class="type">usize</span>, arg0: <span class="type">usize</span>, arg1: <span class="type">usize</span>, arg2: <span class="type">usize</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ret</span>;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        asm!(</span><br><span class="line">            <span class="string">&quot;ecall&quot;</span>,</span><br><span class="line">            <span class="title function_ invoke__">inlateout</span>(<span class="string">&quot;x10&quot;</span>) arg0 =&gt; ret,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x11&quot;</span>) arg1,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x12&quot;</span>) arg2,</span><br><span class="line">            <span class="title function_ invoke__">in</span>(<span class="string">&quot;x17&quot;</span>) which,</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// use sbi call to putchar in console (qemu uart handler)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_putchar</span>(c: <span class="type">usize</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_CONSOLE_PUTCHAR, c, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// use sbi call to getchar from console (qemu uart handler)</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">console_getchar</span>() <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_CONSOLE_GETCHAR, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// use sbi call to shutdown the kernel</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">shutdown</span>() <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="title function_ invoke__">sbi_call</span>(SBI_SHUTDOWN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">panic!</span>(<span class="string">&quot;It should shutdown!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>console.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! SBI console driver, for text output</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::sbi::console_putchar;</span><br><span class="line"><span class="keyword">use</span> core::fmt::&#123;<span class="keyword">self</span>, Write&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Stdout</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Write</span> <span class="keyword">for</span> <span class="title class_">Stdout</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">write_str</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, s: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> fmt::<span class="type">Result</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">c</span> <span class="keyword">in</span> s.<span class="title function_ invoke__">chars</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">console_putchar</span>(c <span class="keyword">as</span> <span class="type">usize</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">print</span>(args: fmt::Arguments) &#123;</span><br><span class="line">    Stdout.<span class="title function_ invoke__">write_fmt</span>(args).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// print string macro</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> print &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>($fmt $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// println string macro</span></span><br><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> println &#123;</span><br><span class="line">    ($fmt: literal $(, $($arg: tt)+)?) =&gt; &#123;</span><br><span class="line">        $crate::console::<span class="title function_ invoke__">print</span>(<span class="built_in">format_args!</span>(<span class="built_in">concat!</span>($fmt, <span class="string">&quot;\n&quot;</span>) $(, $($arg)+)?));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>lang_items.rs</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">panic</span>(_info: &amp;PanicInfo) <span class="punctuation">-&gt;</span> ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">zhou tao</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
